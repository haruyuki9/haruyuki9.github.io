<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构与算法（六）—— 数和二叉树</title>
      <link href="/2025/03/04/%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2025/03/04/%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon simple"><p><strong>数据结构笔记目录：</strong><ol class="series-items"><li><a href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="数据结构与算法（一）—— 线性表的顺序表示及常用操作">数据结构与算法（一）—— 线性表的顺序表示及常用操作</a></li><li><a href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="数据结构与算法（二）—— 线性表的链式表示及常用操作">数据结构与算法（二）—— 线性表的链式表示及常用操作</a></li><li><a href="/2025/01/24/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8/" title="数据结构与算法（三）—— 线性表的应用">数据结构与算法（三）—— 线性表的应用</a></li><li><a href="/2025/02/09/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="数据结构与算法（四）—— 栈和队列">数据结构与算法（四）—— 栈和队列</a></li><li><a href="/2025/02/23/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="数据结构与算法（五）—— 串、数组和广义表">数据结构与算法（五）—— 串、数组和广义表</a></li><li><a href="/2025/03/04/%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构与算法（六）—— 数和二叉树">数据结构与算法（六）—— 数和二叉树</a></li></ol></p></div><h2 id="树的相关定义"><a href="#树的相关定义" class="headerlink" title="树的相关定义"></a>树的相关定义</h2><ul><li>根节点：非空树中无前驱结点的结点</li><li>结点的度：结点拥有的子树数量</li><li>树的度：树内各节点的最大度</li><li>叶子：度等于零的终端节点</li><li>孩子与双亲：结点的子树的根称为该结点的<strong>孩子</strong>，该结点称为孩子的<strong>双亲</strong></li><li>祖先：从根到该结点所经分支上的所有结点</li><li>有序树：将树中每个结点的各子树看成是从左到右有次序的(即不能互换)</li><li>无序树：将树中每个结点的各子树从左到右是没有次序的(即可以互换)</li></ul><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ol><li><strong>在二叉树的第i层上至多有$2^{i-1}$个结点</strong></li><li><strong>深度为k的二叉树至多有$2^{k}-1$个结点</strong></li><li><strong>对于任何一颗二叉树T，如果其叶子数为$n_{0}$，度为2的结点数为$n_{2}$，则$n_{0} &#x3D; n_{2} +1$</strong><br><strong>对于完全二叉树：</strong></li><li><strong>具有n个结点的完全二叉树的深度为$\lfloor log_2(n) \rfloor$</strong></li><li><strong>对于某一编号为i的结点，它的双亲结点必为$\lfloor i&#x2F;2 \rfloor$，左右孩子分别为2i、2i+1</strong></li></ol><h2 id="满二叉树与完全二叉树：可以用顺序存储结构还原的树"><a href="#满二叉树与完全二叉树：可以用顺序存储结构还原的树" class="headerlink" title="满二叉树与完全二叉树：可以用顺序存储结构还原的树"></a>满二叉树与完全二叉树：可以用顺序存储结构还原的树</h2><h3 id="满二叉树：深度为k，且有-2-k-1-个结点"><a href="#满二叉树：深度为k，且有-2-k-1-个结点" class="headerlink" title="满二叉树：深度为k，且有$2^{k}-1$个结点"></a>满二叉树：深度为k，且有$2^{k}-1$个结点</h3><h3 id="完全二叉树：深度为k，每一个结点都与深度为k的满二叉树中编号为1-n的结点一一对应"><a href="#完全二叉树：深度为k，每一个结点都与深度为k的满二叉树中编号为1-n的结点一一对应" class="headerlink" title="完全二叉树：深度为k，每一个结点都与深度为k的满二叉树中编号为1-n的结点一一对应"></a>完全二叉树：深度为k，每一个结点都与深度为k的满二叉树中编号为1-n的结点一一对应</h3><p><strong>特点：</strong></p><ol><li>叶子只可能分布在层次最大的两层</li><li>对任一结点，如果其右子树的最大层次为i，左子树的最大层次必定为i或者i+1</li></ol><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（五）—— 串、数组和广义表</title>
      <link href="/2025/02/23/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
      <url>/2025/02/23/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon simple"><p><strong>数据结构笔记目录：</strong><ol class="series-items"><li><a href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="数据结构与算法（一）—— 线性表的顺序表示及常用操作">数据结构与算法（一）—— 线性表的顺序表示及常用操作</a></li><li><a href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="数据结构与算法（二）—— 线性表的链式表示及常用操作">数据结构与算法（二）—— 线性表的链式表示及常用操作</a></li><li><a href="/2025/01/24/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8/" title="数据结构与算法（三）—— 线性表的应用">数据结构与算法（三）—— 线性表的应用</a></li><li><a href="/2025/02/09/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="数据结构与算法（四）—— 栈和队列">数据结构与算法（四）—— 栈和队列</a></li><li><a href="/2025/02/23/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="数据结构与算法（五）—— 串、数组和广义表">数据结构与算法（五）—— 串、数组和广义表</a></li><li><a href="/2025/03/04/%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构与算法（六）—— 数和二叉树">数据结构与算法（六）—— 数和二叉树</a></li></ol></p></div><h2 id="串的模式匹配：BF算法"><a href="#串的模式匹配：BF算法" class="headerlink" title="串的模式匹配：BF算法"></a>串的模式匹配：BF算法</h2><h3 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_Size 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">char</span> *ch;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><h3 id="DF算法"><a href="#DF算法" class="headerlink" title="DF算法"></a>DF算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">index_BF</span><span class="params">(SString A,SString B)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;<span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= A.length &amp;&amp; j &lt;= B.length)&#123; <span class="comment">//条件1：主串走到结尾。条件2：完全匹配，匹配串走到结尾</span></span><br><span class="line"><span class="keyword">if</span>(A.ch[i] == B.ch[j])&#123;</span><br><span class="line">i++;j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">i = i - (j<span class="number">-1</span>) <span class="number">+1</span>; <span class="comment">//j从1到j走了j-1步，i也走了j-1步，i-（j-1）+1就回到了原位置后一个位置</span></span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">//依次匹配，如果相等，则继续，不相等，则回溯，重新进行下一次匹配</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j &gt;= B.length) <span class="keyword">return</span> i - B.length; <span class="comment">//返回匹配的第一个下标</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主函数内容"><a href="#主函数内容" class="headerlink" title="主函数内容"></a>主函数内容</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">SString A;</span><br><span class="line">SString B;</span><br><span class="line">A . ch = <span class="keyword">new</span> <span class="type">char</span>[max_Size + <span class="number">1</span>];</span><br><span class="line">B . ch = <span class="keyword">new</span> <span class="type">char</span>[max_Size + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> i;<span class="type">int</span> m;<span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;=m ;i++)&#123;</span><br><span class="line">cin &gt;&gt; A . ch[i];</span><br><span class="line">&#125;</span><br><span class="line">A.length = m;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;=n ;i++)&#123;</span><br><span class="line">cin &gt;&gt; B . ch[i];</span><br><span class="line">&#125;</span><br><span class="line">B.length = n;</span><br><span class="line">cout &lt;&lt; <span class="built_in">index_BF</span>(A,B);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="串的模式匹配：KMP算法"><a href="#串的模式匹配：KMP算法" class="headerlink" title="串的模式匹配：KMP算法"></a>串的模式匹配：KMP算法</h2><h3 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h3><blockquote><p>一个讲的通俗易懂的课：<a href="https://www.bilibili.com/video/BV1jb411V78H/?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=e2ccd399c864d0ff152a3d728148037d">KMP算法</a></p></blockquote><p><strong>步骤：</strong></p><ol><li><strong>找到ch[n]位置前的最长公共前后缀，记录串长n，(n+1)为此位置next值</strong></li><li><strong>CH[1]的next规定为0</strong></li></ol><div class="note info no-icon modern"><p><strong>next值含义：</strong><br>0：1号位与主串下一位比较<br>1：1号位与主串当前位比较<br>n：n号位与主串当前位比较</p></div><div class="note default no-icon modern"><p><strong>最长公共前后缀：现有一串ABABAB</strong><br><span style="color: yellowgreen">ch[5]</span>前最长<span style="color: red">前缀</span>、<span style="color: blue">后缀</span>为：<span style="color: red">AB</span><span style="color: blue">AB</span><span style="color: yellowgreen">A</span>B，next[5] &#x3D; 2 + 1 &#x3D; 3<br><br><span style="color: yellowgreen">ch[6]</span>前最长<span style="color: red">前缀</span>为：<span style="color: red">ABA</span>BA<span style="color: yellowgreen">B</span><br><br><span style="color: yellowgreen">ch[6]</span>前最长<span style="color: blue">后缀</span>为：AB<span style="color: blue">ABA</span><span style="color: yellowgreen">B</span>，next[6] &#x3D; 3 + 1 &#x3D; 4</p></div><p><img src="/images/KMP.png" alt="图2.1-1 KMP算法中间略去部分一定不匹配的原因解析"></p><h3 id="求nextval数组"><a href="#求nextval数组" class="headerlink" title="求nextval数组"></a>求nextval数组</h3><p><strong>将ch[i]与ch[next[i]]比较。不相等，则nextval[i] &#x3D; next[i];相等，则nextval[i] &#x3D; next[next[i]]。</strong></p><h2 id="特殊矩阵压缩存储"><a href="#特殊矩阵压缩存储" class="headerlink" title="特殊矩阵压缩存储"></a>特殊矩阵压缩存储</h2><h3 id="对称矩阵-三角矩阵"><a href="#对称矩阵-三角矩阵" class="headerlink" title="对称矩阵&#x2F;三角矩阵"></a>对称矩阵&#x2F;三角矩阵</h3><p><strong>以行序为主序：</strong><br>$对角矩阵数组下三角部分[k]&#x3D; \frac{(i-1)*(1+(i-1))}{2} + (j-1)$<br><strong>上三角部分交换i，j即可</strong></p><p><strong>对于三角矩阵：</strong><br>$下三角矩阵[k]&#x3D; \frac{(i-1)*(1+(i-1))}{2} + (j-1)$</p><p>$上三角矩阵[k]&#x3D; \frac{n*(n+(n-(i-1)+1))}{2} + (j-1)$</p><p>注意：三角矩阵需要额外一个存储常数c的位置<br>$k&#x3D; \frac{n*(1+n)}{2} + 1$</p><h3 id="稀疏矩阵：非零元素"><a href="#稀疏矩阵：非零元素" class="headerlink" title="稀疏矩阵：非零元素&lt;&#x3D;5%的矩阵"></a>稀疏矩阵：非零元素&lt;&#x3D;5%的矩阵</h3><h4 id="有序的双下标法"><a href="#有序的双下标法" class="headerlink" title="有序的双下标法"></a>有序的双下标法</h4><p>由三元组{(row,col,$a_{ij}$)}和矩阵维数(row,col)表示<br>通常在三元组下标为0的位置存放总行数，总列数，总非零元素个数等信息。</p><ul><li>优点：非零元在表中按行序有序存储，因此便于进行依行顺序处理的矩阵运算</li><li>缺点：不能随机存取，若按行号取某一行中的非零元，则需从头开始查找</li></ul><h4 id="十字链表法"><a href="#十字链表法" class="headerlink" title="十字链表法"></a>十字链表法</h4><p><img src="/images/cross_Link.png" alt="图3.2.2-1 KMP算法中间略去部分一定不匹配的原因解析"></p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><ul><li><strong>取表头：取第一个元素</strong></li><li><strong>取表尾：取除了第一个元素外其他元素组成的表</strong></li><li><strong>求表长：所包含元素个数（最外层逗号间隔出的元素个数）</strong></li><li><strong>求表深：最大的括号层数</strong><div class="note no-icon modern"><p><strong>例：广义表A&#x3D;(a,(b,c),(d,e,(f,g,(h)))),求表头，表尾，表长，表深，Head(Head(Tail(Head(Tail(Tail(A))))))</strong></p></div><div class="note info no-icon modern"><ol><li><strong>表头：a</strong></li><li><strong>表尾：((b,c),(d,e,f))</strong></li><li><strong>表长：3</strong></li><li><strong>表深：4</strong></li><li><strong>从后往前开括号，((b,c),(d,e,(f,g,(h))))，((d,e,(f,g,(h))))，(d,e,(f,g,(h)))，((f,g,(h)))，(f,g,(h))，f</strong></li></ol></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（四）—— 栈和队列</title>
      <link href="/2025/02/09/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2025/02/09/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon simple"><p><strong>数据结构笔记目录：</strong><ol class="series-items"><li><a href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="数据结构与算法（一）—— 线性表的顺序表示及常用操作">数据结构与算法（一）—— 线性表的顺序表示及常用操作</a></li><li><a href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="数据结构与算法（二）—— 线性表的链式表示及常用操作">数据结构与算法（二）—— 线性表的链式表示及常用操作</a></li><li><a href="/2025/01/24/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8/" title="数据结构与算法（三）—— 线性表的应用">数据结构与算法（三）—— 线性表的应用</a></li><li><a href="/2025/02/09/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="数据结构与算法（四）—— 栈和队列">数据结构与算法（四）—— 栈和队列</a></li><li><a href="/2025/02/23/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="数据结构与算法（五）—— 串、数组和广义表">数据结构与算法（五）—— 串、数组和广义表</a></li><li><a href="/2025/03/04/%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构与算法（六）—— 数和二叉树">数据结构与算法（六）—— 数和二叉树</a></li></ol></p></div><h2 id="栈与队列的应用实例"><a href="#栈与队列的应用实例" class="headerlink" title="栈与队列的应用实例"></a>栈与队列的应用实例</h2><h3 id="出栈顺序"><a href="#出栈顺序" class="headerlink" title="出栈顺序"></a>出栈顺序</h3><ul><li><strong>条件:</strong> 进栈时允许出栈</li><li><strong>解题思路:</strong> 向上进行时可以跳跃，向下进行时不可以出现跳跃</li></ul><h4 id="Ex-1"><a href="#Ex-1" class="headerlink" title="Ex:1"></a>Ex:1</h4><div class="note no-icon modern"><p><strong>某栈的输入序列为a,b,c,d，下面的四个序列中，不可能为其输出序列的是（）</strong><br><strong>A.a,b,c,d&emsp;&emsp;&emsp;&emsp;B.c,b,d,a&emsp;&emsp;&emsp;&emsp;C.d,c,a,b&emsp;&emsp;&emsp;&emsp;D.a,c,b,d</strong></p></div><p><img src="/images/In_Out_Stack.png" alt="图1.1.1 -1 出栈顺序问题图解"></p><h3 id="进制转换：倒取n-d的余数（d为进制数）"><a href="#进制转换：倒取n-d的余数（d为进制数）" class="headerlink" title="进制转换：倒取n&#x2F;d的余数（d为进制数）"></a>进制转换：倒取n&#x2F;d的余数（d为进制数）</h3><h4 id="EX-2：取-135的二进制数（完整实现）"><a href="#EX-2：取-135的二进制数（完整实现）" class="headerlink" title="EX:2：取 135的二进制数（完整实现）"></a>EX:2：取 135的二进制数<a href="#%E5%BA%94%E7%94%A8%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0">（完整实现）</a></h4><p><img src="/images/swap.gif" alt="图1.2.1 -1 动画演示"></p><h3 id="括号匹配的检验"><a href="#括号匹配的检验" class="headerlink" title="括号匹配的检验"></a>括号匹配的检验</h3><h4 id="依次压入所求括号，遇到右括号便进行出栈操作两次，如果两括号匹配则继续进行入栈和遇到右括号便出栈两次的操作，如果不匹配则退出循环返回括号不匹配"><a href="#依次压入所求括号，遇到右括号便进行出栈操作两次，如果两括号匹配则继续进行入栈和遇到右括号便出栈两次的操作，如果不匹配则退出循环返回括号不匹配" class="headerlink" title="依次压入所求括号，遇到右括号便进行出栈操作两次，如果两括号匹配则继续进行入栈和遇到右括号便出栈两次的操作，如果不匹配则退出循环返回括号不匹配"></a>依次压入所求括号，遇到右括号便进行出栈操作两次，如果两括号匹配则继续进行入栈和遇到右括号便出栈两次的操作，如果不匹配则退出循环返回括号不匹配</h4><h2 id="顺序栈的初始化、判空、清空、求长、销毁"><a href="#顺序栈的初始化、判空、清空、求长、销毁" class="headerlink" title="顺序栈的初始化、判空、清空、求长、销毁"></a>顺序栈的初始化、判空、清空、求长、销毁</h2><h3 id="顺序栈的表示"><a href="#顺序栈的表示" class="headerlink" title="顺序栈的表示"></a>顺序栈的表示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_Size 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SqStack</span>&#123;</span><br><span class="line">    ElemType* base; <span class="comment">//栈底指针</span></span><br><span class="line">    ElemType* top;  <span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="type">int</span> stacksize;  <span class="comment">// 栈的最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><h3 id="顺序栈的初始化"><a href="#顺序栈的初始化" class="headerlink" title="顺序栈的初始化"></a>顺序栈的初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base = (ElemType *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*max_Size);</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//分配内存失败，返回0</span></span><br><span class="line">    S.top = S.base; <span class="comment">//栈底指针等于栈顶指针，判断栈空的条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序栈的判空"><a href="#顺序栈的判空" class="headerlink" title="顺序栈的判空"></a>顺序栈的判空</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清空顺序栈"><a href="#清空顺序栈" class="headerlink" title="清空顺序栈"></a>清空顺序栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ClearStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base) S.top = S.base; <span class="comment">//并不需要全部释放，只需栈底指针等于栈顶指针（满足栈空条件）即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求顺序栈长度"><a href="#求顺序栈长度" class="headerlink" title="求顺序栈长度"></a>求顺序栈长度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> S.top - S.base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="销毁顺序栈"><a href="#销毁顺序栈" class="headerlink" title="销毁顺序栈"></a>销毁顺序栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base)&#123;</span><br><span class="line">        <span class="built_in">free</span>(S.base); <span class="comment">//S.base是一块包含栈所有元素的空间</span></span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        S.top = S.base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="顺序栈的入栈与出栈"><a href="#顺序栈的入栈与出栈" class="headerlink" title="顺序栈的入栈与出栈"></a>顺序栈的入栈与出栈</h2><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base == S.stacksize) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//判断是否栈满，如果栈满则返回溢出</span></span><br><span class="line">    *S.top = e; <span class="comment">//解引用S所指的地址，将e压入栈</span></span><br><span class="line">    S.top++; <span class="comment">//栈顶上移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//判断是否为空栈，如果为空栈则返回溢出</span></span><br><span class="line">    S.top--; <span class="comment">//先进行栈顶下移</span></span><br><span class="line">    e = *S.top; <span class="comment">//后进行解引用S所指的地址，存入e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用：十进制转换二进制数"><a href="#应用：十进制转换二进制数" class="headerlink" title="应用：十进制转换二进制数"></a>应用：十进制转换二进制数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_Size 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SqStack</span>&#123;</span><br><span class="line"><span class="type">int</span>* top = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>* base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> stacksize = max_Size;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top - S.base == S.stacksize) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">*S.top = e;</span><br><span class="line">S.top++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top == S.base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">S.top--;</span><br><span class="line"><span class="type">int</span> t = *S.top;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqStack S;</span><br><span class="line">S.base = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*max_Size);</span><br><span class="line">S.top = S.base;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> t = x%<span class="number">2</span>;</span><br><span class="line"><span class="built_in">Push</span>(S,x%<span class="number">2</span>);</span><br><span class="line">x = (x - t)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(S.top != S.base) cout &lt;&lt; <span class="built_in">Pop</span>(S);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链栈的初始化、判空"><a href="#链栈的初始化、判空" class="headerlink" title="链栈的初始化、判空"></a>链栈的初始化、判空</h2><h3 id="链栈的初始化"><a href="#链栈的初始化" class="headerlink" title="链栈的初始化"></a>链栈的初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>节点定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span>&#123;</span><br><span class="line">    Elemtype data;</span><br><span class="line">    StackNode* next;</span><br><span class="line">&#125;StackNode,*LinkStack;</span><br></pre></td></tr></table></figure><h3 id="链栈的判空"><a href="#链栈的判空" class="headerlink" title="链栈的判空"></a>链栈的判空</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackEmpty</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//链栈为空</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链栈的出入栈操作"><a href="#链栈的出入栈操作" class="headerlink" title="链栈的出入栈操作"></a>链栈的出入栈操作</h2><div class="note danger no-icon modern"><p><strong>与普通链表不同，链栈是一个不带头结点的链表，链栈指针S指向的是链表末尾元素（因为链表后进先出的特性）</strong><br><strong>如图所示：</strong><img class="inline-img" src="/images/link_Stack.png" style="height:100px" /></p></div><h3 id="链栈的入栈"><a href="#链栈的入栈" class="headerlink" title="链栈的入栈"></a>链栈的入栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(LinkStack &amp;S,Elemtype e)</span></span>&#123;</span><br><span class="line">    StackNode* p = (StackNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(StackNode));</span><br><span class="line">    p -&gt; data = e; <span class="comment">//创建要插入的新结点p</span></span><br><span class="line">    p -&gt; next = S; <span class="comment">//</span></span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链栈的出栈"><a href="#链栈的出栈" class="headerlink" title="链栈的出栈"></a>链栈的出栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(LinkStack &amp;S,Elemtype &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果传入的链栈为空栈，返回溢出</span></span><br><span class="line">    e = S -&gt; data; <span class="comment">//存储被释放的结点的数据</span></span><br><span class="line">    StackNode* p = S; <span class="comment">//生成临时结点p用于存放被释放的S结点地址</span></span><br><span class="line">    S = S -&gt; next; <span class="comment">//下移栈顶</span></span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">//释放指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列的真溢出、假溢出"><a href="#队列的真溢出、假溢出" class="headerlink" title="队列的真溢出、假溢出"></a>队列的真溢出、假溢出</h2><p><strong>真溢出：front&#x3D;&#x3D;0;rear&#x3D;&#x3D;max_Size</strong><br><strong>假溢出：front！&#x3D;0;rear&#x3D;&#x3D;max_Size</strong><br><strong>由于假溢出的存在，大部分队列使用的是顺序循环结构</strong></p><h2 id="队列的表示、入队、出队"><a href="#队列的表示、入队、出队" class="headerlink" title="队列的表示、入队、出队"></a>队列的表示、入队、出队</h2><h3 id="队列的表示"><a href="#队列的表示" class="headerlink" title="队列的表示"></a>队列的表示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SqQueue</span>&#123;</span><br><span class="line">    ElemType* base; <span class="comment">//初始化动态分配存储空间</span></span><br><span class="line">    <span class="type">int</span> front; <span class="comment">//队头下标</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">//队尾下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的入队"><a href="#队列的入队" class="headerlink" title="队列的入队"></a>队列的入队</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Q.base[Q.rear] = x;</span><br><span class="line">Q.rear = (Q.rear + <span class="number">1</span>) % max_Size;</span><br></pre></td></tr></table></figure><h3 id="队列的出队"><a href="#队列的出队" class="headerlink" title="队列的出队"></a>队列的出队</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = Q.base[Q.front];</span><br><span class="line">Q.front = (Q.front + <span class="number">1</span>) % max_Size;</span><br></pre></td></tr></table></figure><div class="note danger no-icon modern"><p><strong>注意：</strong> </p><ol><li><strong>循环队列并非是一个真正的循环结构，而是通过取余（%）运算来实现循环。</strong></li><li><strong>循环队列无法判断队空、队满，二者条件均为rear&#x3D;&#x3D;front，如图所示：</strong><br><img src="/images/queue.png" alt="图7.3-1 循环队列示意图"></li></ol></div><div class="note info no-icon modern"><p><strong>解决方案：</strong></p><ol><li><strong>另外设一个标志以区别队空队满</strong></li><li><strong>另设一个变量记录元素个数</strong></li><li><strong>少用一个元素空间</strong></li></ol></div><h3 id="基于少用一个空间的区分循环队列队满队空的方法"><a href="#基于少用一个空间的区分循环队列队满队空的方法" class="headerlink" title="基于少用一个空间的区分循环队列队满队空的方法"></a>基于少用一个空间的区分循环队列队满队空的方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Q.rear + <span class="number">1</span>) % max_Size =   Q.front; <span class="comment">//队尾指针 +1 等于队头指针时证明队满</span></span><br><span class="line">Q.rear == Q.front; <span class="comment">//队尾指针等于队头指针时证明队空</span></span><br></pre></td></tr></table></figure><h2 id="队列的初始化、求长"><a href="#队列的初始化、求长" class="headerlink" title="队列的初始化、求长"></a>队列的初始化、求长</h2><h3 id="队列的初始化"><a href="#队列的初始化" class="headerlink" title="队列的初始化"></a>队列的初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.base = (ElemType *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType) * max_Size); <span class="comment">//分配空间</span></span><br><span class="line">    <span class="keyword">if</span>(!Q.base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;  <span class="comment">//队头队尾指针初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列求长"><a href="#队列求长" class="headerlink" title="队列求长"></a>队列求长</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear-Q.front + max_Size) % max_Size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/queue_2.png" alt="图8.2-1 队列求长示意图"></p><h2 id="队列的入队、出队"><a href="#队列的入队、出队" class="headerlink" title="队列的入队、出队"></a>队列的入队、出队</h2><h3 id="队列的入队-1"><a href="#队列的入队-1" class="headerlink" title="队列的入队"></a>队列的入队</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % max_Size == Q.front) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//队满，返回错误</span></span><br><span class="line">    Q.base[Q.rear] = e; <span class="comment">//队尾插入新元素</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % max_Size; <span class="comment">//队尾指针+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的出队-1"><a href="#队列的出队-1" class="headerlink" title="队列的出队"></a>队列的出队</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//队空，返回错误</span></span><br><span class="line">    e = Q.base[Q.front]; <span class="comment">//将队头出队元素赋值给e</span></span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % max_Size; <span class="comment">//队头指针+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链队列相关操作"><a href="#链队列相关操作" class="headerlink" title="链队列相关操作"></a>链队列相关操作</h2><h3 id="链队列定义"><a href="#链队列定义" class="headerlink" title="链队列定义"></a>链队列定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    Qnode* next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueue</span>&#123;</span><br><span class="line">    QNode* front; <span class="comment">//队头指针</span></span><br><span class="line">    QNode* rear; <span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue; <span class="comment">//把两个指针合成一个结构体看起来更简洁。</span></span><br></pre></td></tr></table></figure><h3 id="链队列初始化"><a href="#链队列初始化" class="headerlink" title="链队列初始化"></a>链队列初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.rear = Q.front = (QNode *)<span class="built_in">mallco</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链队列销毁"><a href="#链队列销毁" class="headerlink" title="链队列销毁"></a>链队列销毁</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123; </span><br><span class="line">    <span class="keyword">while</span>(Q.front!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">        QNode* p = Q.front;</span><br><span class="line">        Q.front = Q.front -&gt; next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125; </span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链队列入队"><a href="#链队列入队" class="headerlink" title="链队列入队"></a>链队列入队</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType e)</span></span>&#123;</span><br><span class="line">    QNode* p = (QNode *)<span class="built_in">mallco</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    p -&gt; data = e;</span><br><span class="line">    p -&gt; next = <span class="literal">NULL</span>; <span class="comment">//创建要入队的结点</span></span><br><span class="line">    Q.rear -&gt; next = p; <span class="comment">//入队</span></span><br><span class="line">    Q.rear = p; <span class="comment">//尾指针后移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链队列出队"><a href="#链队列出队" class="headerlink" title="链队列出队"></a>链队列出队</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear = Q.front) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//空队列时返回0</span></span><br><span class="line">    QNode* p = Q.front -&gt; next; <span class="comment">//p指向要出队元素</span></span><br><span class="line">    e = p -&gt; data; <span class="comment">//将出队元素记录给e</span></span><br><span class="line">    Q.front -&gt; next = p -&gt; next; <span class="comment">//front指针后移</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front; <span class="comment">//尾指针元素已出队，此时队列只剩头结点，即空队列。此时Q.rear为空。故人为满足空表条件：Q.rear = Q.front;</span></span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">//释放p</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新标日单词表-初级（1）</title>
      <link href="/2025/02/08/%E6%96%B0%E6%A0%87%E6%97%A5%E5%8D%95%E8%AF%8D%E8%A1%A8-%E5%88%9D%E7%BA%A7%EF%BC%881%EF%BC%89/"/>
      <url>/2025/02/08/%E6%96%B0%E6%A0%87%E6%97%A5%E5%8D%95%E8%AF%8D%E8%A1%A8-%E5%88%9D%E7%BA%A7%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon simple"><p><strong>新标日单词表-初级目录：</strong><ol class="series-items"><li><a href="/2025/02/08/%E6%96%B0%E6%A0%87%E6%97%A5%E5%8D%95%E8%AF%8D%E8%A1%A8-%E5%88%9D%E7%BA%A7%EF%BC%881%EF%BC%89/" title="新标日单词表-初级（1）">新标日单词表-初级（1）</a></li></ol></p></div><table><thead><tr><th align="left">单词</th><th align="left">假名</th><th align="left">声调</th><th align="left">词义</th></tr></thead><tbody><tr><td align="left">中国人</td><td align="left">ちゅうごくじん</td><td align="left">4</td><td align="left">中国人</td></tr><tr><td align="left">日本人</td><td align="left">にほんじん</td><td align="left">4</td><td align="left">日本人</td></tr><tr><td align="left">韓国人</td><td align="left">かんこくじん</td><td align="left">4</td><td align="left">韩国人</td></tr><tr><td align="left">アメリカ人</td><td align="left">あめりかじん</td><td align="left">4</td><td align="left">美国人</td></tr><tr><td align="left">フランス人</td><td align="left">ふらんすじん</td><td align="left">4</td><td align="left">法国人</td></tr><tr><td align="left">学生</td><td align="left">がくせい</td><td align="left">0</td><td align="left">学生</td></tr><tr><td align="left">留学生</td><td align="left">りゅうがくせい</td><td align="left">3</td><td align="left">留学生</td></tr><tr><td align="left">教授</td><td align="left">きょうじゅ</td><td align="left">0</td><td align="left">教授</td></tr><tr><td align="left">社員</td><td align="left">しゃいん</td><td align="left">1</td><td align="left">社员</td></tr><tr><td align="left">会社員</td><td align="left">かいしゃいん</td><td align="left">3</td><td align="left">公司职员</td></tr><tr><td align="left">店員</td><td align="left">てんいん</td><td align="left">0</td><td align="left">店员</td></tr><tr><td align="left">研修生</td><td align="left">けんしゅせい</td><td align="left">3</td><td align="left">进修生</td></tr><tr><td align="left">企業</td><td align="left">きぎょう</td><td align="left">1</td><td align="left">企业</td></tr><tr><td align="left">大学</td><td align="left">だいがく</td><td align="left">0</td><td align="left">大学</td></tr><tr><td align="left">父</td><td align="left">ちち</td><td align="left">1、2</td><td align="left">父亲</td></tr><tr><td align="left">課長</td><td align="left">かちょう</td><td align="left">0</td><td align="left">科长</td></tr><tr><td align="left">社長</td><td align="left">しゃちょう</td><td align="left">0</td><td align="left">总经理</td></tr><tr><td align="left">出迎え</td><td align="left">でむかえ</td><td align="left">0</td><td align="left">迎接</td></tr><tr><td align="left">あの人</td><td align="left">あのひと</td><td align="left">2</td><td align="left">那个人</td></tr><tr><td align="left">私</td><td align="left">わたし</td><td align="left">0</td><td align="left">我</td></tr><tr><td align="left">あなた</td><td align="left">あなた</td><td align="left">2</td><td align="left">你</td></tr><tr><td align="left">とうも</td><td align="left">とうも</td><td align="left">1</td><td align="left">非常，很</td></tr><tr><td align="left">はい</td><td align="left">はい</td><td align="left">1</td><td align="left">是</td></tr><tr><td align="left">いいえ</td><td align="left">いいえ</td><td align="left">3</td><td align="left">不是</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日语(初级)单词表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 单词表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏多项式的运算非伪码完整实现</title>
      <link href="/2025/02/02/%E7%A8%80%E7%96%8F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97%E9%9D%9E%E4%BC%AA%E7%A0%81%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/02/02/%E7%A8%80%E7%96%8F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97%E9%9D%9E%E4%BC%AA%E7%A0%81%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon simple"><p>伪码描述过于抽象，于是决定自己动手按照逻辑实现一次。看到AC的时候实在是太过激动，于是决定另开一篇文章分享一下实现源码。<br>代码写的及其的不美观，要是能再精简一下就好了</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PNode</span>&#123;</span><br><span class="line"><span class="type">float</span> coef; <span class="comment">//系数</span></span><br><span class="line"><span class="type">int</span> expn; <span class="comment">//指数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PNode</span>* next; <span class="comment">//指针域</span></span><br><span class="line">&#125;PNode,*Polynomal;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_L</span><span class="params">(Polynomal LA,Polynomal LB,Polynomal &amp;LC)</span></span>&#123;</span><br><span class="line">   PNode* p = LA -&gt; next;PNode* q = LB -&gt; next; <span class="comment">//p,q指针指向LA,LB两表首元素</span></span><br><span class="line">   PNode* r = LC; <span class="comment">//r指向LC表</span></span><br><span class="line">   <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)&#123;  <span class="comment">//循环条件为LA,LB两表均未到达表尾</span></span><br><span class="line">    <span class="keyword">if</span>(p -&gt; expn == q -&gt; expn)&#123; <span class="comment">//第一层if：p，q指数相等情况</span></span><br><span class="line">      <span class="keyword">if</span>(p -&gt; coef + q -&gt; coef == <span class="number">0</span>)&#123; <span class="comment">//第二层if：判断p，q系数是否相加为零</span></span><br><span class="line">      p = p -&gt; next;</span><br><span class="line">      q = q -&gt; next; <span class="comment">//系数和为零，向后移动p，q指针，两结点均不加入LC表</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123; <span class="comment">//第二层if：p，q系数相加不为零</span></span><br><span class="line">        PNode* s = (PNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(PNode));</span><br><span class="line">        s -&gt; next = <span class="literal">NULL</span>; <span class="comment">//初始化一个s结点以便插入LC表</span></span><br><span class="line">        s -&gt; coef =  p -&gt; coef + q -&gt; coef;</span><br><span class="line">        s -&gt; expn = p -&gt; expn; <span class="comment">//新结点指数为p（或q）指数，系数为p，q系数之和</span></span><br><span class="line">        r -&gt; next = s; <span class="comment">//将s结点插入LC表</span></span><br><span class="line">        r = r -&gt; next;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">      q = q -&gt; next; <span class="comment">//向后移动p，q，r指针</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p -&gt; expn &lt; q -&gt; expn)&#123; <span class="comment">//第一层if：p指数小于q指数</span></span><br><span class="line">        r -&gt; next = p;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        r = r -&gt; next; <span class="comment">//将p所指向结点作为r的下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//第一层if：p指数大于q指数</span></span><br><span class="line">        r -&gt; next = q;</span><br><span class="line">        q = q -&gt; next;</span><br><span class="line">        r = r -&gt; next; <span class="comment">//将q所指向结点作为r的下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">r -&gt; next = p ? p : q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m , n;</span><br><span class="line">    cin &gt;&gt; m; cin &gt;&gt; n;</span><br><span class="line">    Polynomal LA = (PNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(PNode));</span><br><span class="line">    Polynomal LB = (PNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(PNode));</span><br><span class="line">    Polynomal LC = (PNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(PNode));</span><br><span class="line">    LA -&gt; expn = <span class="number">0</span>;LA -&gt; coef = <span class="number">0</span>;</span><br><span class="line">    LB -&gt; expn = <span class="number">0</span>;LB -&gt; coef = <span class="number">0</span>;</span><br><span class="line">    LC -&gt; expn = <span class="number">0</span>;LC -&gt; coef = <span class="number">0</span>;</span><br><span class="line">    LA -&gt; next = <span class="literal">NULL</span>;LB -&gt; next = <span class="literal">NULL</span>;LC -&gt; next = <span class="literal">NULL</span>; <span class="comment">//新建三个链表LA,LB,LC，并初始化</span></span><br><span class="line">    PNode* p = LA;</span><br><span class="line">    PNode* q = LB; <span class="comment">//p，q结点分别表示访问到的位置</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt; m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t1;</span><br><span class="line">        <span class="type">int</span> t2;</span><br><span class="line">        cin &gt;&gt; t1;</span><br><span class="line">        cin &gt;&gt; t2; <span class="comment">//读入新结点指数，系数值</span></span><br><span class="line">        Polynomal t = (PNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(PNode));</span><br><span class="line">        t -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        t -&gt; expn = t1;</span><br><span class="line">        t -&gt; coef = t2; <span class="comment">//新建结点以便于插入LA表</span></span><br><span class="line">        p -&gt; next = t; <span class="comment">//将新结点插入LA表</span></span><br><span class="line">        p = p -&gt; next; <span class="comment">//向后移动p指针位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt; n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t1;</span><br><span class="line">        <span class="type">int</span> t2;</span><br><span class="line">        cin &gt;&gt; t1;</span><br><span class="line">        cin &gt;&gt; t2;</span><br><span class="line">        Polynomal t = (PNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(PNode));</span><br><span class="line">        t -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        t -&gt; expn = t1;</span><br><span class="line">        t -&gt; coef = t2;</span><br><span class="line">        q -&gt; next = t;</span><br><span class="line">        q = q -&gt; next; <span class="comment">//同上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MergeList_L</span>(LA,LB,LC); <span class="comment">//调用多项式相加函数</span></span><br><span class="line">    PNode* r = LC -&gt; next; <span class="comment">//r结点指向LC表首元结点</span></span><br><span class="line">    <span class="keyword">while</span> (r != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %.0f\n&quot;</span>,r -&gt; expn,r -&gt; coef);</span><br><span class="line">        r = r -&gt; next;</span><br><span class="line">    &#125; <span class="comment">//遍历LC</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 6 0 1 1 2 3 5 0 -1 1 3 2 6 3 7 4 8 5 9</span><br></pre></td></tr></table></figure><p><strong>答案</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 5</span><br><span class="line">2 6</span><br><span class="line">3 12</span><br><span class="line">4 8</span><br><span class="line">5 9</span><br></pre></td></tr></table></figure><p><img src="/images/mergelist_L_Test.png" alt="AC胜利结算"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人最爱术力口30选</title>
      <link href="/2025/01/30/%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%88%B1%E6%9C%AF%E5%8A%9B%E5%8F%A330%E9%80%89/"/>
      <url>/2025/01/30/%E4%B8%AA%E4%BA%BA%E6%9C%80%E7%88%B1%E6%9C%AF%E5%8A%9B%E5%8F%A330%E9%80%89/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon simple"><p>偶然在朋友圈看到了一张30天推歌挑战的图片，于是决定借那张图片上的问题推荐几首自己喜欢的歌。（部分问题有修改）另外，点击对应歌曲名可以跳转网易云歌曲页！如果碰到没听过的务必要点开来听听看！(题外：双子骨真好吃!!!)<br><strong>因为原图的后15个问题过于难答，遂选择了按p主推荐的方式继续完成这篇文章（或许是按p主喜爱度来排序的）</strong></p></div><table><thead><tr><th align="center"></th><th align="center"></th><th align="center">个人最爱术力口30选</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><a href="#1">在歌名里带有颜色的歌</a></td><td align="center"><a href="#2">在歌名里带有数字的歌</a></td><td align="center"><a href="#3">听到会想起夏天的歌</a></td><td align="center"><a href="#4">会想到宁愿忘记的人的歌</a></td><td align="center"><a href="#5">最令你感动的歌</a></td></tr><tr><td align="center"><a href="#6">一首会让你想尽情跳舞的歌</a></td><td align="center"><a href="#7">听了会摇头晃脑的歌</a></td><td align="center"><a href="#8">关于毒品（药物）或酒精的歌</a></td><td align="center"><a href="#9">让人感到开心的歌</a></td><td align="center"><a href="#10">让人感到难过的歌</a></td></tr><tr><td align="center"><a href="#11">永远不会厌倦的歌</a></td><td align="center"><a href="#12">00年代最喜欢的曲子</a></td><td align="center"><a href="#13">想在婚礼上放的歌</a></td><td align="center"><a href="#14">10年代最喜欢的曲子</a></td><td align="center"><a href="#15">人生中听过的第一首术曲</a></td></tr><tr><td align="center"><a href="#16">はるまきごはん（春卷饭）</a></td><td align="center"><a href="#17">wowaka</a></td><td align="center"><a href="#18">ピノキオピー（匹诺曹p）</a></td><td align="center"><a href="#19">いよわ（胃弱）</a></td><td align="center"><a href="#20">Sohbana</a></td></tr><tr><td align="center"><a href="#21">John</a></td><td align="center"><a href="#22">煮ル果実</a></td><td align="center"><a href="#23"></a></td><td align="center"><a href="#24"></a></td><td align="center"><a href="#25"></a></td></tr><tr><td align="center"><a href="#26"></a></td><td align="center"><a href="#27"></a></td><td align="center"><a href="#28"></a></td><td align="center"><a href="#29"></a></td><td align="center"><a href="#30"></a></td></tr></tbody></table><h2 id="在歌名里带有颜色的歌"><a href="#在歌名里带有颜色的歌" class="headerlink" title="在歌名里带有颜色的歌"></a>在歌名里带有颜色的歌<span id="1"></span></h2><h3 id="コバルトメモリーズ（蔚蓝色的回忆）"><a href="#コバルトメモリーズ（蔚蓝色的回忆）" class="headerlink" title="コバルトメモリーズ（蔚蓝色的回忆）"></a><a href="https://music.163.com/song?id=1335797416&uct2=U2FsdGVkX1/ntqpGXIo8VusWeh/w3MGN1EMdyPxYW+4=">コバルトメモリーズ（蔚蓝色的回忆）</a></h3><h4 id="欢快的曲调-饭特有的软绵绵声线，独属于夏日的慵懒！"><a href="#欢快的曲调-饭特有的软绵绵声线，独属于夏日的慵懒！" class="headerlink" title="欢快的曲调,饭特有的软绵绵声线，独属于夏日的慵懒！"></a>欢快的曲调,饭特有的软绵绵声线，独属于夏日的慵懒！</h4><blockquote><p>「誰も居ない街 誰も居ない空、世界は二人だけかもしれないね」<br>&emsp;&emsp;空荡荡的街道 空荡荡的天空，世界上说不定只剩下我们两个人了 — コバルトメモリーズ</p></blockquote><h2 id="在歌名里带有数字的歌"><a href="#在歌名里带有数字的歌" class="headerlink" title="在歌名里带有数字的歌"></a>在歌名里带有数字的歌<span id="2"></span></h2><h3 id="六兆年と一夜物語（六兆年零一夜物语）"><a href="#六兆年と一夜物語（六兆年零一夜物语）" class="headerlink" title="六兆年と一夜物語（六兆年零一夜物语）"></a><a href="https://music.163.com/song?id=26142121&uct2=U2FsdGVkX19lzPMOCjP860JoF9JXlDGlgbHTEcDjJkM=">六兆年と一夜物語（六兆年零一夜物语）</a></h3><h4 id="堀江晶太的一代炸厕所神曲，希腊奶-希腊奶"><a href="#堀江晶太的一代炸厕所神曲，希腊奶-希腊奶" class="headerlink" title="堀江晶太的一代炸厕所神曲，希腊奶~希腊奶~"></a>堀江晶太的一代炸厕所神曲，希腊奶~希腊奶~</h4><blockquote><p>「知らない知らない、僕は何も知らない」<br>&emsp;&emsp;不知道啊不知道啊，我什么也不知道啊！ — 六兆年と一夜物語</p></blockquote><h2 id="听到会想起夏天的歌"><a href="#听到会想起夏天的歌" class="headerlink" title="听到会想起夏天的歌"></a>听到会想起夏天的歌<span id="3"></span></h2><h3 id="コバルトメモリーズ（蔚蓝色的回忆）-1"><a href="#コバルトメモリーズ（蔚蓝色的回忆）-1" class="headerlink" title="コバルトメモリーズ（蔚蓝色的回忆）"></a><a href="https://music.163.com/song?id=1335797416&uct2=U2FsdGVkX1/ntqpGXIo8VusWeh/w3MGN1EMdyPxYW+4=">コバルトメモリーズ（蔚蓝色的回忆）</a></h3><h4 id="虽然重复了但是！找来找去还是这首最符合了！本来想选一首橙星的歌但是选来选去都没有这首有感觉！"><a href="#虽然重复了但是！找来找去还是这首最符合了！本来想选一首橙星的歌但是选来选去都没有这首有感觉！" class="headerlink" title="虽然重复了但是！找来找去还是这首最符合了！本来想选一首橙星的歌但是选来选去都没有这首有感觉！"></a>虽然重复了但是！找来找去还是这首最符合了！本来想选一首橙星的歌但是选来选去都没有这首有感觉！</h4><h2 id="会想到宁愿忘记的人的歌"><a href="#会想到宁愿忘记的人的歌" class="headerlink" title="会想到宁愿忘记的人的歌"></a>会想到宁愿忘记的人的歌<span id="4"></span></h2><h3 id="1-6-Out-of-the-gravity"><a href="#1-6-Out-of-the-gravity" class="headerlink" title="1&#x2F;6 -Out of the gravity-"></a><a href="https://music.163.com/song?id=28382729&uct2=U2FsdGVkX1+UtFI7E6/zQOMhVg+YPWY2bc7vFcqGD+U=">1&#x2F;6 -Out of the gravity-</a></h3><h4 id="初中的时候超级喜欢这首，好像真的坐着宇宙飞船飞到了重力只有地球1-6的月亮上。可惜一些往事和这首歌联系在了一起，要是那份痛苦也能变成1-6就好了。"><a href="#初中的时候超级喜欢这首，好像真的坐着宇宙飞船飞到了重力只有地球1-6的月亮上。可惜一些往事和这首歌联系在了一起，要是那份痛苦也能变成1-6就好了。" class="headerlink" title="初中的时候超级喜欢这首，好像真的坐着宇宙飞船飞到了重力只有地球1&#x2F;6的月亮上。可惜一些往事和这首歌联系在了一起，要是那份痛苦也能变成1&#x2F;6就好了。"></a>初中的时候超级喜欢这首，好像真的坐着宇宙飞船飞到了重力只有地球1&#x2F;6的月亮上。可惜一些往事和这首歌联系在了一起，要是那份痛苦也能变成1&#x2F;6就好了。</h4><blockquote><p>「辛いコトや悲しいコトも全部1&#x2F;6」<br>&emsp;&emsp;无论是痛苦还是悲伤全部都只剩1&#x2F;6 — 1&#x2F;6 -Out of the gravity-</p></blockquote><h2 id="最令你感动的歌"><a href="#最令你感动的歌" class="headerlink" title="最令你感动的歌"></a>最令你感动的歌<span id="5"></span></h2><h3 id="銀河録（银河录）"><a href="#銀河録（银河录）" class="headerlink" title="銀河録（银河录）"></a><a href="https://music.163.com/song?id=492999798&uct2=U2FsdGVkX188FP6mONJu354xFkBE4CKLMP7QoZWX1nc=">銀河録（银河录）</a></h3><h4 id="神曲，情感调动太到位了！（？）听这首总是会忍不住想哭。"><a href="#神曲，情感调动太到位了！（？）听这首总是会忍不住想哭。" class="headerlink" title="神曲，情感调动太到位了！（？）听这首总是会忍不住想哭。"></a>神曲，情感调动太到位了！（？）听这首总是会忍不住想哭。</h4><blockquote><p>「銀河みたいな 銀河みたいな、銀河みたいな街だったね」<br>&emsp;&emsp;宛若银河一般，宛若银河一般，那是宛若银河一般的街道呢 — 銀河録</p></blockquote><h2 id="一首会让你想尽情跳舞的歌"><a href="#一首会让你想尽情跳舞的歌" class="headerlink" title="一首会让你想尽情跳舞的歌"></a>一首会让你想尽情跳舞的歌<span id="6"></span></h2><h3 id="しかばねの踊り（尸骸之舞）"><a href="#しかばねの踊り（尸骸之舞）" class="headerlink" title="しかばねの踊り（尸骸之舞）"></a><a href="https://music.163.com/song?id=29185031&uct2=U2FsdGVkX1/5MKlGOo2SoMzXpzmSHkSNiepUrxfHwkM=">しかばねの踊り（尸骸之舞）</a></h3><h4 id="无言，请看VCR"><a href="#无言，请看VCR" class="headerlink" title="无言，请看VCR"></a>无言，请看VCR<img class="inline-img" src="/images/bone.gif" style="height:50px" /></h4><blockquote><p>「しかばね音頭で踊りましょう」<br>&emsp;&emsp;伴着尸骸音头 起舞吧 — しかばねの踊り</p></blockquote><h2 id="听了会摇头晃脑的歌"><a href="#听了会摇头晃脑的歌" class="headerlink" title="听了会摇头晃脑的歌"></a>听了会摇头晃脑的歌<span id="7"></span></h2><h3 id="ストリーミングハート（流心）"><a href="#ストリーミングハート（流心）" class="headerlink" title="ストリーミングハート（流心）"></a><a href="https://music.163.com/song?id=28364360&uct2=U2FsdGVkX18O2C7Ps2LBb9svibgzDquSynGWrtuDhOw=">ストリーミングハート（流心）</a></h3><h4 id="我是真喜欢Deco原来的曲风，又毒又躁。更古早时期的小甜曲也喜欢！不过真的不喜欢最近的Deco（我自己称之为后吸血鬼时代）（耻度中二度拉满的特有名词环节）。"><a href="#我是真喜欢Deco原来的曲风，又毒又躁。更古早时期的小甜曲也喜欢！不过真的不喜欢最近的Deco（我自己称之为后吸血鬼时代）（耻度中二度拉满的特有名词环节）。" class="headerlink" title="我是真喜欢Deco原来的曲风，又毒又躁。更古早时期的小甜曲也喜欢！不过真的不喜欢最近的Deco（我自己称之为后吸血鬼时代）（耻度中二度拉满的特有名词环节）。"></a>我是真喜欢Deco原来的曲风，又毒又躁。更古早时期的小甜曲也喜欢！不过真的不喜欢最近的Deco（我自己称之为后吸血鬼时代）（耻度中二度拉满的特有名词环节）。</h4><blockquote><p>「アイマイにしたいのさ、好きでいたって 歪んでく内声」<br>&emsp;&emsp;想要變得曖昧啊，說道曾喜歡過你 如此扭曲了的心聲 — ストリーミングハート</p></blockquote><h2 id="关于毒品（药物）或酒精的歌"><a href="#关于毒品（药物）或酒精的歌" class="headerlink" title="关于毒品（药物）或酒精的歌"></a>关于毒品（药物）或酒精的歌<span id="8"></span></h2><h3 id="シャンティ（Shanti）"><a href="#シャンティ（Shanti）" class="headerlink" title="シャンティ（Shanti）"></a>シャンティ（Shanti）</h3><h4 id="唐人街毒贩kaito伪装牛郎不打麻药噶人腰子，wotaku的毒曲听起来是真的爽。"><a href="#唐人街毒贩kaito伪装牛郎不打麻药噶人腰子，wotaku的毒曲听起来是真的爽。" class="headerlink" title="唐人街毒贩kaito伪装牛郎不打麻药噶人腰子，wotaku的毒曲听起来是真的爽。"></a>唐人街毒贩kaito伪装牛郎不打麻药噶人腰子，wotaku的毒曲听起来是真的爽。</h4><blockquote><p>「生きてればお客、死んでれば商材」<br>&emsp;&emsp;只要活着的话便是客人，只要死去的话便是商品 — シャンティ</p></blockquote><h2 id="让人感到开心的歌"><a href="#让人感到开心的歌" class="headerlink" title="让人感到开心的歌 "></a>让人感到开心的歌 <span id="9"></span></h2><h3 id="好き！雪！本気-マジ-マジック（喜欢！雪！真实的魔法）"><a href="#好き！雪！本気-マジ-マジック（喜欢！雪！真实的魔法）" class="headerlink" title="好き！雪！本気(マジ)マジック（喜欢！雪！真实的魔法）"></a><a href="https://music.163.com/song?id=28387072&uct2=U2FsdGVkX19egq/VeMkPnXtr8j8h4UFTVFiK9mVTvVI=">好き！雪！本気(マジ)マジック（喜欢！雪！真实的魔法）</a></h3><h4 id="永远忘不掉的一天。和朋友们出去玩雪真的超级开心！"><a href="#永远忘不掉的一天。和朋友们出去玩雪真的超级开心！" class="headerlink" title="永远忘不掉的一天。和朋友们出去玩雪真的超级开心！"></a>永远忘不掉的一天。和朋友们出去玩雪真的超级开心！</h4><blockquote><p>「Ah Whipしたケーキのような街は 好き！雪！本気 Magic」<br>&emsp;&emsp;Ah 像撒上奶油般的街道 喜欢！雪！真实 Magic — 好き！雪！本気(マジ)マジック</p></blockquote><h2 id="让人感到难过的歌"><a href="#让人感到难过的歌" class="headerlink" title="让人感到难过的歌"></a>让人感到难过的歌<span id="10"></span></h2><h3 id="アンノウン・マザーグース（不为人知的鹅妈妈童谣）"><a href="#アンノウン・マザーグース（不为人知的鹅妈妈童谣）" class="headerlink" title="アンノウン・マザーグース（不为人知的鹅妈妈童谣）"></a><a href="https://music.163.com/song?id=502455381&uct2=U2FsdGVkX190QSPY97R0oNePGFa5ULWPWSk2kSduj/4=">アンノウン・マザーグース（不为人知的鹅妈妈童谣）</a></h3><h4 id="遥望令和之人在平成的绝唱，wowaka最后的术力口，哎，天妒英才。wowaka本人都不容易复刻的超高bpm，疾走感术曲Top1！"><a href="#遥望令和之人在平成的绝唱，wowaka最后的术力口，哎，天妒英才。wowaka本人都不容易复刻的超高bpm，疾走感术曲Top1！" class="headerlink" title="遥望令和之人在平成的绝唱，wowaka最后的术力口，哎，天妒英才。wowaka本人都不容易复刻的超高bpm，疾走感术曲Top1！"></a>遥望令和之人在平成的绝唱，wowaka最后的术力口，哎，天妒英才。wowaka本人都不容易复刻的超高bpm，疾走感术曲Top1！</h4><blockquote><p>「あたしが愛を語るのなら その眼には如何、映像る？」<br>&emsp;&emsp;若要由我来谈论爱的话、在那双眼中映出的又是何等景象？ — アンノウン・マザーグース</p></blockquote><h2 id="永远不会厌倦的歌"><a href="#永远不会厌倦的歌" class="headerlink" title="永远不会厌倦的歌"></a>永远不会厌倦的歌<span id="11"></span></h2><h3 id="November"><a href="#November" class="headerlink" title="November"></a><a href="https://music.163.com/song?id=492999801&uct2=U2FsdGVkX1+UV6GI5YYg7b5QZlCMKV7jJ4T5yNHzZd8=">November</a></h3><h4 id="永远的Top1，饭曲中最喜欢的一首，也是所有术力口中最喜欢的一首。本站个人简介下就是这首歌的台词！下雪的日子必听的歌。（除了这首还有喜欢！雪！真实的魔法）"><a href="#永远的Top1，饭曲中最喜欢的一首，也是所有术力口中最喜欢的一首。本站个人简介下就是这首歌的台词！下雪的日子必听的歌。（除了这首还有喜欢！雪！真实的魔法）" class="headerlink" title="永远的Top1，饭曲中最喜欢的一首，也是所有术力口中最喜欢的一首。本站个人简介下就是这首歌的台词！下雪的日子必听的歌。（除了这首还有喜欢！雪！真实的魔法）"></a>永远的Top1，饭曲中最喜欢的一首，也是所有术力口中最喜欢的一首。本站个人简介下就是这首歌的台词！下雪的日子必听的歌。（除了这首还有<a href="#9">喜欢！雪！真实的魔法</a>）</h4><blockquote><p>「ああガラス越しの藍さ」<br>&emsp;&emsp;啊 隔着玻璃的蓝 — November</p></blockquote><h2 id="00年代最喜欢的曲子"><a href="#00年代最喜欢的曲子" class="headerlink" title="00年代最喜欢的曲子"></a>00年代最喜欢的曲子<span id="12"></span></h2><h3 id="Magnet"><a href="#Magnet" class="headerlink" title="Magnet"></a><a href="https://music.163.com/song?id=22730073&uct2=U2FsdGVkX18LFkD2SmkUZjOipqB2ZbPNPWceefs2l0o=">Magnet</a></h3><h4 id="是鱼葱！我们有救了！个人觉得这首比胧月好听。"><a href="#是鱼葱！我们有救了！个人觉得这首比胧月好听。" class="headerlink" title="是鱼葱！我们有救了！个人觉得这首比胧月好听。"></a>是鱼葱！我们有救了！个人觉得这首比胧月好听。</h4><blockquote><p>「抱き寄せて欲しい　確かめて欲しい」<br>&emsp;&emsp;想要被拥入你怀中 想要确认心意 — Magnet</p></blockquote><h2 id="想在婚礼上放的歌"><a href="#想在婚礼上放的歌" class="headerlink" title="想在婚礼上放的歌"></a>想在婚礼上放的歌<span id="13"></span></h2><h3 id="偏食"><a href="#偏食" class="headerlink" title="偏食"></a><a href="https://music.163.com/song?id=1841222221&uct2=U2FsdGVkX1+YOBkkqE9z3UhAOYbksEgIQUf+obgnV8c=">偏食</a></h3><h4 id="最有婚礼氛围的一首，对钢琴曲的刻板印象。或许会用来做婚礼上会播放的那种恋爱VCR的BGM"><a href="#最有婚礼氛围的一首，对钢琴曲的刻板印象。或许会用来做婚礼上会播放的那种恋爱VCR的BGM" class="headerlink" title="最有婚礼氛围的一首，对钢琴曲的刻板印象。或许会用来做婚礼上会播放的那种恋爱VCR的BGM"></a>最有婚礼氛围的一首，对钢琴曲的刻板印象。或许会用来做婚礼上会播放的那种恋爱VCR的BGM</h4><blockquote><p>「ダーリン、ダーリン、私を愛して。もっと、もっと、壊れるくらい。」<br>&emsp;&emsp;Darling，Darling，请爱我吧。多些，多些，直到堕落。 — 偏食</p></blockquote><h2 id="10年代最喜欢的曲子"><a href="#10年代最喜欢的曲子" class="headerlink" title="10年代最喜欢的曲子"></a>10年代最喜欢的曲子<span id="14"></span></h2><h3 id="黄金数"><a href="#黄金数" class="headerlink" title="黄金数"></a><a href="https://music.163.com/song?id=1825071525&uct2=U2FsdGVkX18RKUxN/qoh1Anvztl93dcRK3r/yiv6W+c=">黄金数</a></h3><h4 id="新兴p主中最喜欢的一位，这首是把胃弱既混乱又有序的个人风格阐释到极致的集大成作。"><a href="#新兴p主中最喜欢的一位，这首是把胃弱既混乱又有序的个人风格阐释到极致的集大成作。" class="headerlink" title="新兴p主中最喜欢的一位，这首是把胃弱既混乱又有序的个人风格阐释到极致的集大成作。"></a>新兴p主中最喜欢的一位，这首是把胃弱既混乱又有序的个人风格阐释到极致的集大成作。</h4><blockquote><p>「銃弾 ひとつ飛んだ、それは虚ろ 果ては骸、まるで真夜中の昼間、贈り主のいないおくりもの」<br>&emsp;&emsp;飞来的一颗子弹，那即是空虚 最终化为尸骸，就像在深夜中出现的白昼，没有赠送者的礼物。 — 黄金数</p></blockquote><h2 id="人生中听过的第一首术曲"><a href="#人生中听过的第一首术曲" class="headerlink" title="人生中听过的第一首术曲"></a>人生中听过的第一首术曲<span id="15"></span></h2><h3 id="ローリンガール（翻滚少女）"><a href="#ローリンガール（翻滚少女）" class="headerlink" title="ローリンガール（翻滚少女）"></a><a href="https://music.163.com/song?id=22699098&uct2=U2FsdGVkX19Y2mAaZ3hCuqwyOTH1/rsgp5cMmuEkfRQ=">ローリンガール（翻滚少女）</a></h3><h4 id="其实应该是甩葱歌，小学时代在妈妈的耳机中听到的。但是因为这首才喜欢上了术力口，所以最终在这两首里选择了滚女"><a href="#其实应该是甩葱歌，小学时代在妈妈的耳机中听到的。但是因为这首才喜欢上了术力口，所以最终在这两首里选择了滚女" class="headerlink" title="其实应该是甩葱歌，小学时代在妈妈的耳机中听到的。但是因为这首才喜欢上了术力口，所以最终在这两首里选择了滚女"></a>其实应该是甩葱歌，小学时代在妈妈的耳机中听到的。但是因为这首才喜欢上了术力口，所以最终在这两首里选择了滚女</h4><blockquote><p>「もう一回、もう一回、「私は今日も転がります。」と、少女は言う 少女は言う、言葉に意味を奏でながら！」<br>&emsp;&emsp;再一次，又一次。「我今天也跌倒了呢。」少女喃喃说道 少女喃喃自言自语，包含的意义就在言语字词之中奏响了！<br> — ローリンガール</p></blockquote><hr style="border: none; border-top: 2px dashed #39c5bb;"><h2 id="はるまきごはん（春卷饭）"><a href="#はるまきごはん（春卷饭）" class="headerlink" title="はるまきごはん（春卷饭）"></a>はるまきごはん（春卷饭）<span id="16"></span></h2><h3 id="November-1"><a href="#November-1" class="headerlink" title="November"></a><a href="https://music.163.com/song?id=492999801&uct2=U2FsdGVkX1+UV6GI5YYg7b5QZlCMKV7jJ4T5yNHzZd8=">November</a></h3><h3 id="ぽかぽかの星（暖暖的星）"><a href="#ぽかぽかの星（暖暖的星）" class="headerlink" title="ぽかぽかの星（暖暖的星）"></a><a href="https://music.163.com/song?id=1474338763&uct2=U2FsdGVkX1+Jjt+1QKjfvnCiH2VsV6U4CHzbs0wG07M=">ぽかぽかの星（暖暖的星）</a></h3><h4 id="心中的饭曲Top1还得是November啊！不过因为推荐过了。所以选择了另外一首很喜欢的。暖暖的星！在冬天听会让人觉得暖洋洋的歌。"><a href="#心中的饭曲Top1还得是November啊！不过因为推荐过了。所以选择了另外一首很喜欢的。暖暖的星！在冬天听会让人觉得暖洋洋的歌。" class="headerlink" title="心中的饭曲Top1还得是November啊！不过因为推荐过了。所以选择了另外一首很喜欢的。暖暖的星！在冬天听会让人觉得暖洋洋的歌。"></a>心中的饭曲Top1还得是<a href="#11">November</a>啊！不过因为推荐过了。所以选择了另外一首很喜欢的。暖暖的星！在冬天听会让人觉得暖洋洋的歌。</h4><blockquote><p>「故郷でも旅人でもあかりを灯す」<br>&emsp;&emsp;在故乡的人和旅人都点起了灯火 — ぽかぽかの星</p></blockquote><h3 id="銀河録（银河录）-1"><a href="#銀河録（银河录）-1" class="headerlink" title="銀河録（银河录）"></a><a href="https://music.163.com/song?id=492999798&uct2=U2FsdGVkX188FP6mONJu354xFkBE4CKLMP7QoZWX1nc=">銀河録（银河录）</a></h3><h2 id="wowaka"><a href="#wowaka" class="headerlink" title="wowaka"></a>wowaka<span id="17"></span></h2><h3 id="アンノウン・マザーグース（不为人知的鹅妈妈童谣）-1"><a href="#アンノウン・マザーグース（不为人知的鹅妈妈童谣）-1" class="headerlink" title="アンノウン・マザーグース（不为人知的鹅妈妈童谣）"></a><a href="https://music.163.com/song?id=502455381&uct2=U2FsdGVkX190QSPY97R0oNePGFa5ULWPWSk2kSduj/4=">アンノウン・マザーグース（不为人知的鹅妈妈童谣）</a></h3><h3 id="ワールズエンド・ダンスホール（世末舞厅）"><a href="#ワールズエンド・ダンスホール（世末舞厅）" class="headerlink" title="ワールズエンド・ダンスホール（世末舞厅）"></a><a href="https://music.163.com/song?id=22699095&uct2=U2FsdGVkX1+pCnQ4Ke4oKG7IQs7oLPtZu4gjWRRDusc=">ワールズエンド・ダンスホール（世末舞厅）</a></h3><h4 id="wowaka的第一首神话曲，现在回过头再看这首的歌词还真是令人感慨"><a href="#wowaka的第一首神话曲，现在回过头再看这首的歌词还真是令人感慨" class="headerlink" title="wowaka的第一首神话曲，现在回过头再看这首的歌词还真是令人感慨"></a>wowaka的第一首神话曲，现在回过头再看这首的歌词还真是令人感慨</h4><blockquote><p>「さよなら、お元気で。終わる世界に言う」<br>&emsp;&emsp;永别了，望你珍重，向终结的世界说道 — ワールズエンド・ダンスホール</p></blockquote><h3 id="ローリンガール（翻滚少女）-1"><a href="#ローリンガール（翻滚少女）-1" class="headerlink" title="ローリンガール（翻滚少女）"></a><a href="https://music.163.com/song?id=22699098&uct2=U2FsdGVkX19Y2mAaZ3hCuqwyOTH1/rsgp5cMmuEkfRQ=">ローリンガール（翻滚少女）</a></h3><h2 id="ピノキオピー（匹诺曹p）"><a href="#ピノキオピー（匹诺曹p）" class="headerlink" title="ピノキオピー（匹诺曹p）"></a>ピノキオピー（匹诺曹p）<span id="18"></span></h2><h3 id="内臓ありますか（请问有内脏吗）"><a href="#内臓ありますか（请问有内脏吗）" class="headerlink" title="内臓ありますか（请问有内脏吗）"></a><a href="https://music.163.com/song?id=1347526544&uct2=U2FsdGVkX1+gePWE6jxdNIl+oO90RM49fYqo9GBYNDQ=">内臓ありますか（请问有内脏吗）</a></h3><h4 id="今天也在做不想做的事吗（笑）"><a href="#今天也在做不想做的事吗（笑）" class="headerlink" title="今天也在做不想做的事吗（笑）"></a>今天也在做不想做的事吗（笑）</h4><blockquote><p>「外面が綺麗でも　醜い内面が嫌いでも、生皮剥いだら　おんなじだよ　みんな」<br>&emsp;&emsp;就算外表是美丽的 就算讨厌丑陋的内心，剥掉外皮大家都是一样的 各位 — 内臓ありますか</p></blockquote><h2 id="いよわ（胃弱）"><a href="#いよわ（胃弱）" class="headerlink" title="いよわ（胃弱）"></a>いよわ（胃弱）<span id="19"></span></h2><h3 id="黄金数-1"><a href="#黄金数-1" class="headerlink" title="黄金数"></a><a href="https://music.163.com/song?id=1825071525&uct2=U2FsdGVkX18RKUxN/qoh1Anvztl93dcRK3r/yiv6W+c=">黄金数</a></h3><h3 id="大女優さん（大女主）"><a href="#大女優さん（大女主）" class="headerlink" title="大女優さん（大女主）"></a><a href="https://music.163.com/song?id=2036133286&uct2=U2FsdGVkX1/egIZ1+pi44hALBbgsMvI5GzkA48u+zFo=">大女優さん（大女主）</a></h3><h4 id="破碎感！眩晕感！Super-Iyowa-Time！资质平平的“大女主”沉浸在自己成名的幻梦中，眼睁睁的看着自己的梦无可奈何的破碎。"><a href="#破碎感！眩晕感！Super-Iyowa-Time！资质平平的“大女主”沉浸在自己成名的幻梦中，眼睁睁的看着自己的梦无可奈何的破碎。" class="headerlink" title="破碎感！眩晕感！Super Iyowa Time！资质平平的“大女主”沉浸在自己成名的幻梦中，眼睁睁的看着自己的梦无可奈何的破碎。"></a>破碎感！眩晕感！Super Iyowa Time！资质平平的“大女主”沉浸在自己成名的幻梦中，眼睁睁的看着自己的梦无可奈何的破碎。</h4><blockquote><p>「ショートフィルムを録ろう。約五十秒、眠気がピークになれる邦画」<br>&emsp;&emsp;来录制短片吧.大约五十秒,睡意达到顶峰的电影 — 大女優さん</p></blockquote><h3 id="アプリコット（杏子）"><a href="#アプリコット（杏子）" class="headerlink" title="アプリコット（杏子）"></a><a href="https://music.163.com/song?id=1903309181&uct2=U2FsdGVkX18Jl0+E+QtUPW3DcPhivg0ifofRCgnHBUU=">アプリコット（杏子）</a></h3><p>无论是谁都没法逃脱生老病死，「ゆりかごから墓場まで」从落入摇篮到埋入墓地，像熟透的杏子一样悄无声息的死去</p><blockquote><p>「小さくなった公園へ」<br>&emsp;&emsp;朝着变小的公园走去 — アプリコット</p></blockquote><h3 id="あだぽしゃ（尸蜡）、うらぽしゃ（里蜡）"><a href="#あだぽしゃ（尸蜡）、うらぽしゃ（里蜡）" class="headerlink" title="あだぽしゃ（尸蜡）、うらぽしゃ（里蜡）"></a><a href="https://music.163.com/song?id=1903311034&uct2=U2FsdGVkX18Y7kDd+S3thNi7UQdGIhoJUPqgkuGen5k=">あだぽしゃ（尸蜡）</a>、<a href="https://music.163.com/song?id=1903311035&uct2=U2FsdGVkX19fXh2R5II08wjT1eTa2631xs3C1Z86Zfw=">うらぽしゃ（里蜡）</a></h3><h4 id="拖着因为雪崩死去的爱人的尸体在雪地中孤独的行走，到底会是一种怎样的心情呢？躺在地上死去的里蜡又是怎样想的呢？（-啧）"><a href="#拖着因为雪崩死去的爱人的尸体在雪地中孤独的行走，到底会是一种怎样的心情呢？躺在地上死去的里蜡又是怎样想的呢？（-啧）" class="headerlink" title="拖着因为雪崩死去的爱人的尸体在雪地中孤独的行走，到底会是一种怎样的心情呢？躺在地上死去的里蜡又是怎样想的呢？（*啧）"></a>拖着因为雪崩死去的爱人的尸体在雪地中孤独的行走，到底会是一种怎样的心情呢？躺在地上死去的里蜡又是怎样想的呢？（*啧）</h4><blockquote><p>「私たちもう一生分かり合えないと、分かっていたでしょう」<br>&emsp;&emsp;相信你已经知道 我们这一生都不会，相互理解了对吧 — あだぽしゃ</p></blockquote><h2 id="Sohbana"><a href="#Sohbana" class="headerlink" title="Sohbana"></a>Sohbana<span id="20"></span></h2><h3 id="はなれあうゼロ（互斥零）"><a href="#はなれあうゼロ（互斥零）" class="headerlink" title="はなれあうゼロ（互斥零）"></a><a href="https://music.163.com/song?id=2038608719&uct2=U2FsdGVkX1+VGiqAFXGnNCmGchw23JayfJIBgBTVrcQ=">はなれあうゼロ（互斥零）</a></h3><h4 id="没开玩笑，我的耳机里有小兔子在蹦来蹦去。慢性毒，乍一听只会觉得很乱，get到点再去听越听越觉得好听。"><a href="#没开玩笑，我的耳机里有小兔子在蹦来蹦去。慢性毒，乍一听只会觉得很乱，get到点再去听越听越觉得好听。" class="headerlink" title="没开玩笑，我的耳机里有小兔子在蹦来蹦去。慢性毒，乍一听只会觉得很乱，get到点再去听越听越觉得好听。"></a>没开玩笑，我的耳机里有小兔子在蹦来蹦去。慢性毒，乍一听只会觉得很乱，get到点再去听越听越觉得好听。</h4><blockquote><p>「wanna be 一足飛びに\wanna be 愛される身」<br>&emsp;&emsp;wanna be 一跃而至,wanna be 被爱之身 — はなれあうゼロ</p></blockquote><h2 id="John"><a href="#John" class="headerlink" title="John"></a>John<span id="21"></span></h2><h3 id="rabbit"><a href="#rabbit" class="headerlink" title="rabbit"></a><a href="https://music.163.com/song?id=1453342315&uct2=U2FsdGVkX1/aGU28424ROjrYPeXBdJtM85awRLllTjs=">rabbit</a></h3><h4 id="yellow-monkey-DRUNK-BABY-壮爹的歌有一种很浓的爵士味，喝酒喝的晕乎乎的感觉。"><a href="#yellow-monkey-DRUNK-BABY-壮爹的歌有一种很浓的爵士味，喝酒喝的晕乎乎的感觉。" class="headerlink" title="yellow monkey DRUNK BABY!!!!!!壮爹的歌有一种很浓的爵士味，喝酒喝的晕乎乎的感觉。"></a>yellow monkey DRUNK BABY!!!!!!壮爹的歌有一种很浓的爵士味，喝酒喝的晕乎乎的感觉。</h4><blockquote><p>「教えて、rabbit!狂気(クレージー)なんだ 今夜の夜景(ネオン)は綺麗か？」<br>&emsp;&emsp;告诉我吧，rabbit！真是疯狂啊 今晚的夜色是否美丽呢？ — rabbit</p></blockquote><h3 id="春嵐（春岚）"><a href="#春嵐（春岚）" class="headerlink" title="春嵐（春岚）"></a><a href="https://music.163.com/song?id=1456486939&uct2=U2FsdGVkX1/newPx1R3WNwfGFnjUlsxyFyiJjotG8Ng=">春嵐（春岚）</a></h3><h4 id="神曲，无需多言！"><a href="#神曲，无需多言！" class="headerlink" title="神曲，无需多言！"></a>神曲，无需多言！</h4><blockquote><p>「春の嵐呼んだ 僕は泣いた 心傷つけられた」<br>&emsp;&emsp;呼唤了春天的暴风雨 我哭了起来 心已经受了伤 — 春嵐</p></blockquote><h3 id="darling"><a href="#darling" class="headerlink" title="darling"></a><a href="https://music.163.com/song?id=1453342314&uct2=U2FsdGVkX18Dc4mRgQCfkkjzb87bMDN0JpJtj8UIuJw=">darling</a></h3><h4 id="对我来说有着特别的情感的一首。听到这首会想起对我来说很重要的人。"><a href="#对我来说有着特别的情感的一首。听到这首会想起对我来说很重要的人。" class="headerlink" title="对我来说有着特别的情感的一首。听到这首会想起对我来说很重要的人。"></a>对我来说有着特别的情感的一首。听到这首会想起对我来说很重要的人。</h4><blockquote><p>「泣くなよdandy、二人は孤独のlonely star、気弱なメンタルがクッと、去って行ったんだ嫌々」<br>&emsp;&emsp;不要哭呀dandy，我们两人是孤独的lonely star，懦弱的内心世界，我真的讨厌离去啊 — darling</p></blockquote><h2 id="煮ル果実"><a href="#煮ル果実" class="headerlink" title="煮ル果実"></a>煮ル果実<span id="22"></span></h2><h3 id="トラフィック・ジャム（Traffic-Jam）"><a href="#トラフィック・ジャム（Traffic-Jam）" class="headerlink" title="トラフィック・ジャム（Traffic Jam）"></a><a href="https://music.163.com/song?id=1388172420&uct2=U2FsdGVkX1840x7HYRR59vymWhXJjQSZHVPDfllfrOo=">トラフィック・ジャム（Traffic Jam）</a></h3><h4 id="交通堵塞！因为这首喜欢上了煮果。完全的毒曲！听完之后满脑子都在Deuce！Deuce！Deuce！"><a href="#交通堵塞！因为这首喜欢上了煮果。完全的毒曲！听完之后满脑子都在Deuce！Deuce！Deuce！" class="headerlink" title="交通堵塞！因为这首喜欢上了煮果。完全的毒曲！听完之后满脑子都在Deuce！Deuce！Deuce！"></a>交通堵塞！因为这首喜欢上了煮果。完全的毒曲！听完之后满脑子都在Deuce！Deuce！Deuce！</h4><blockquote><p>「Deuce Deuce Deuce!君が逝くまで」<br>&emsp;&emsp;倒霉 倒霉 倒霉！直到你逝去为止 — トラフィック・ジャム</p></blockquote><h3 id="紗痲（纱麻）、キルマー-Klimer"><a href="#紗痲（纱麻）、キルマー-Klimer" class="headerlink" title="紗痲（纱麻）、キルマー(Klimer)"></a><a href="https://music.163.com/song?id=1396522693&uct2=U2FsdGVkX18DYKfk9Fhz8kYmbsnNOJXWjb60cqNZ6WQ=">紗痲（纱麻）</a>、<a href="https://music.163.com/song?id=1396524584&uct2=U2FsdGVkX1/bSK85CpRai92mKPNSbxUMSrcb1DPuLug=">キルマー(Klimer)</a></h3><h4 id="太好了！又是女同！看守与犯人的禁忌之恋。（笑）"><a href="#太好了！又是女同！看守与犯人的禁忌之恋。（笑）" class="headerlink" title="太好了！又是女同！看守与犯人的禁忌之恋。（笑）"></a>太好了！又是女同！看守与犯人的禁忌之恋。（笑）</h4><blockquote><p>「上っ面な愛を愛と呼べんなら」<br>&emsp;&emsp;如果把表面的爱称作爱的话 — 紗痲</p></blockquote><h3 id="ヲズワルド（WOZWALD）"><a href="#ヲズワルド（WOZWALD）" class="headerlink" title="ヲズワルド（WOZWALD）"></a><a href="https://music.163.com/song?id=1396524585&uct2=U2FsdGVkX1/nJBCq3jIvdzX7V5OH+qNJtBBj6RCRoY0=">ヲズワルド（WOZWALD）</a></h3><h4 id="酷酷的，闷闷的贝斯听起来很毒。"><a href="#酷酷的，闷闷的贝斯听起来很毒。" class="headerlink" title="酷酷的，闷闷的贝斯听起来很毒。"></a>酷酷的，闷闷的贝斯听起来很毒。</h4><blockquote><p>「停滞した幸福に溺れてくの」<br>&emsp;&emsp;沉湎于停滞的幸福中吧 — ヲズワルド</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vocaloid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 术力口 </tag>
            
            <tag> Vocaloid </tag>
            
            <tag> ボーカロイド </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（三）—— 线性表的应用</title>
      <link href="/2025/01/24/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2025/01/24/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon simple"><p><strong>数据结构笔记目录：</strong><ol class="series-items"><li><a href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="数据结构与算法（一）—— 线性表的顺序表示及常用操作">数据结构与算法（一）—— 线性表的顺序表示及常用操作</a></li><li><a href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="数据结构与算法（二）—— 线性表的链式表示及常用操作">数据结构与算法（二）—— 线性表的链式表示及常用操作</a></li><li><a href="/2025/01/24/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8/" title="数据结构与算法（三）—— 线性表的应用">数据结构与算法（三）—— 线性表的应用</a></li><li><a href="/2025/02/09/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="数据结构与算法（四）—— 栈和队列">数据结构与算法（四）—— 栈和队列</a></li><li><a href="/2025/02/23/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="数据结构与算法（五）—— 串、数组和广义表">数据结构与算法（五）—— 串、数组和广义表</a></li><li><a href="/2025/03/04/%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构与算法（六）—— 数和二叉树">数据结构与算法（六）—— 数和二叉树</a></li></ol></p></div><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="循环链表的合并"><a href="#循环链表的合并" class="headerlink" title="循环链表的合并"></a>循环链表的合并</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Connect</span><span class="params">(LinkList Ta,LinkList Tb)</span></span>&#123; <span class="comment">//传入两个循环链表的尾指针，本操作为返回一个新表，故无需使用引用类型（&amp;）进行传参</span></span><br><span class="line">    Nnode* p = Ta -&gt; next; <span class="comment">//p存储表头结点</span></span><br><span class="line">    Ta -&gt; next = Tb -&gt; next -&gt; next; <span class="comment">//Ta表尾的next指向Tb首元结点</span></span><br><span class="line">    <span class="built_in">free</span>(Tb -&gt; next); <span class="comment">//释放Tb头结点</span></span><br><span class="line">    Tb -&gt; next = p; <span class="comment">//Tb的next指向Ta表头结点</span></span><br><span class="line">    <span class="keyword">return</span> Tb; <span class="comment">//返回修改后的循环链表尾指针</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="双向链表的定义"><a href="#双向链表的定义" class="headerlink" title="双向链表的定义"></a>双向链表的定义</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DuLNode</span>&#123;</span><br><span class="line">   Elemtype data;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">DuLNode</span>* prior;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">DLNode</span>* next;</span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br></pre></td></tr></table></figure><h3 id="双向链表的插入"><a href="#双向链表的插入" class="headerlink" title="双向链表的插入"></a>双向链表的插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListInsert_Dul</span><span class="params">(DuLinkList &amp;L,<span class="type">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!(p=<span class="built_in">GetElemP_Dul</span>(L,i))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   DuLNode* s = (DuLNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DuLNode)); </span><br><span class="line">   s -&gt; data = e; <span class="comment">//为要插入的s结点分配空间</span></span><br><span class="line">   s -&gt; prior = p -&gt; prior;</span><br><span class="line">   s -&gt; next = p; <span class="comment">//设置要插入节点的前驱和后继</span></span><br><span class="line">   <span class="comment">/* 这一步我这样处理是因为首先进行这两步不会影响原表的结构，便于理解 */</span></span><br><span class="line">   (p -&gt; prior) -&gt; next = s; <span class="comment">//p -&gt; prior 即为a结点，设置a结点的后继为s</span></span><br><span class="line">   p -&gt; prior = s; <span class="comment">//p结点指向b结点，设置b结点的前驱为s</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p><img src="/images/DuL_Ins.png" alt="图2.2-1 双向链表的插入"></p><h3 id="双向链表的删除"><a href="#双向链表的删除" class="headerlink" title="双向链表的删除"></a>双向链表的删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!(p=<span class="built_in">GetElemP_Dul</span>(L,i))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   e = p -&gt; data;</span><br><span class="line">   (p -&gt; next) -&gt; prior = p -&gt; prior; <span class="comment">//p -&gt; next 为p的后继结点，设置此结点前驱域为p的前驱</span></span><br><span class="line">   (p -&gt; prior) -&gt; next = p -&gt; next; <span class="comment">//p -&gt; prior 为p的前驱结点，设置此结点后继域为p的后继</span></span><br><span class="line">   <span class="built_in">free</span>(p); <span class="comment">//释放要删除的节点</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="单链表、循环链表和双向链表的时间效率比较"><a href="#单链表、循环链表和双向链表的时间效率比较" class="headerlink" title="单链表、循环链表和双向链表的时间效率比较"></a>单链表、循环链表和双向链表的时间效率比较</h3><table><thead><tr><th align="center"></th><th align="center">查找表头结点（首元结点）</th><th align="center">查找表尾结点</th><th align="center">查找结点*P的前驱结点</th></tr></thead><tbody><tr><td align="center">带头结点的<strong>单链表</strong>L</td><td align="center">L -&gt; next<br> 时间复杂度O(1)</td><td align="center">从L -&gt; next依次向后遍历<br> 时间复杂度O(n)</td><td align="center">通过p -&gt; next无法找到其前驱</td></tr><tr><td align="center">带头结点的<strong>仅设头指针L</strong>的<strong>循环</strong>单链表</td><td align="center">L -&gt; next<br> 时间复杂度O(1)</td><td align="center">从L -&gt; next依次向后遍历<br> 时间复杂度O(n)</td><td align="center">通过p -&gt; next可以找到其前驱<br>时间复杂度O(n)</td></tr><tr><td align="center">带头结点的<strong>仅设尾指针R</strong>的<strong>循环</strong>单链表</td><td align="center">R -&gt; next -&gt; next<br> 时间复杂度O(1)</td><td align="center">R<br> 时间复杂度O(1)</td><td align="center">通过p -&gt; next可以找到其前驱<br>时间复杂度O(n)</td></tr><tr><td align="center">带头结点的<strong>双向循环</strong>链表L</td><td align="center">L -&gt; next<br>时间复杂度O(1)</td><td align="center">L -&gt; prior<br> 时间复杂度O(1)</td><td align="center">通过p -&gt; prior<br>时间复杂度O(1)</td></tr></tbody></table><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h3><p><strong>优点：</strong></p><ol><li>结点空间可以动态申请和释放</li><li>插入和删除时不需要移动数据元素</li></ol><p><strong>缺点：</strong></p><ol><li>存储密度小，每个结点的指针域会占用额外的存储空间</li><li>$存储密度 &#x3D; \frac{结点数据本身占用的空间}{结点占用的空间总量}$（即$\frac{数据域所占空间}{数据域所占空间+指针域所占空间}$）（顺序表的存储密度为1）</li><li>链式存储结构是<strong>非随机存取</strong>结构，对任一结点的操作都要从头指针依指针链查找到该节点</li></ol><p><strong>适用情况</strong></p><ol><li>表长变化较大</li><li>频繁进行插入或删除操作</li></ol><h3 id="顺序表的优缺点"><a href="#顺序表的优缺点" class="headerlink" title="顺序表的优缺点"></a>顺序表的优缺点</h3><p><strong>优点：</strong></p><ol><li>存储密度为1，不用为表示结点间逻辑结构增加而外的存储开销</li><li><strong>随机存取</strong>，按位置访问元素的时间复杂度为O（1）</li></ol><p><strong>缺点：</strong></p><ol><li>结点空间预先分配，可能会导致闲置或溢出</li><li>插入和删除时平均约移动表中一半元素，时间复杂度O(n)</li></ol><p><strong>适用情况</strong></p><ol><li>表长变化不大，且能事先确定变化范围</li><li>很少进行插入或删除操作，经常按元素位置序号访问数据元素</li></ol><h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><h3 id="线性表的合并（将Lb表插入到La表后）"><a href="#线性表的合并（将Lb表插入到La表后）" class="headerlink" title="线性表的合并（将Lb表插入到La表后）"></a>线性表的合并（将Lb表插入到La表后）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">union</span><span class="params">(List &amp;La,List &amp;Lb)</span></span>&#123;</span><br><span class="line">   La_Len = <span class="built_in">ListLength</span>(La);</span><br><span class="line">   Lb_Len = <span class="built_in">ListLength</span>(Lb);</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">1</span>,i &lt;= Lb_Len.i++)&#123;</span><br><span class="line">      <span class="built_in">GetElem</span>(i,Lb,e); <span class="comment">//获得Lb的第i个元素</span></span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">LocateElem</span>(La,e)) <span class="built_in">ListInsert</span>(&amp;La,e,La_Len++); <span class="comment">//检查La中有无e元素，如果没有，则将e元素插入到La表尾</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法的时间复杂度为：</strong>O(ListLength(La) * ListLength(Lb))</p><h3 id="有序表的合并（顺序表实现）"><a href="#有序表的合并（顺序表实现）" class="headerlink" title="有序表的合并（顺序表实现）"></a>有序表的合并（顺序表实现）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList LA,SqList LB,SqList &amp;LC)</span></span>&#123;</span><br><span class="line">   <span class="type">int</span>* pa = LA.elem;</span><br><span class="line">   <span class="type">int</span>* pb = LB.elem; <span class="comment">//指针pa和pb分别指向两个顺序表首元素</span></span><br><span class="line">   LC.length = LA.length + LB.length; <span class="comment">//信标长度为两表长度和</span></span><br><span class="line">   LC.elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) *max_Size); <span class="comment">//为合并后的新表分配空间</span></span><br><span class="line">   <span class="type">int</span>* pc = LC.elem;  <span class="comment">//指针pc指向LC表首元素</span></span><br><span class="line">   <span class="type">int</span>* pa_Last = LA.elem + LA.lenght - <span class="number">1</span>; </span><br><span class="line">   <span class="type">int</span>* pb_Last = LB.elem + LB.lenght - <span class="number">1</span>; <span class="comment">//pa_Last,pb_Last 分别指向LA，LB两表最后一个元素</span></span><br><span class="line">   <span class="keyword">while</span>(pa &lt;= pa_Last &amp;&amp; pb &lt;= pb_Last)&#123; <span class="comment">//循环条件为两表未到达表尾</span></span><br><span class="line">      <span class="keyword">if</span>(*pa &gt;= *pb) *pc++ = *pb++; <span class="comment">//可写为&#123;*pc = *pb;pc++;pb++;&#125;</span></span><br><span class="line">      <span class="keyword">else</span> *pc++ = *pa++; <span class="comment">//可写为&#123;*pc = *pa;*pc++;*pa++;&#125;</span></span><br><span class="line">      <span class="comment">/*由于C/C++的运算符优先级规则，赋值运算符（=）的优先级低于后缀递增运算符（++），但是，后缀递增运算符的操作顺序为：先使用（或赋值）当前值，再进行递增操作。 */</span></span><br><span class="line">   &#125;</span><br><span class="line">      <span class="keyword">while</span>(pa &lt;= pa_Last)*pc++ = *pa++;</span><br><span class="line">      <span class="keyword">while</span>(pa &lt;= pa_Last)*pc++ = *pb++; <span class="comment">//将未到达末尾的表中剩余元素添加至LC表表尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="有序表的合并（链表实现）"><a href="#有序表的合并（链表实现）" class="headerlink" title="有序表的合并（链表实现）"></a>有序表的合并（链表实现）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList LA,LinkList LB,LinkList &amp;LC)</span></span>&#123;</span><br><span class="line">   LNode* p = LA -&gt; next;LNode* q = LB -&gt; next;</span><br><span class="line">   LNode* r = LC = LA; <span class="comment">//用LA头结点做LC头结点，目的是将LB表整合到LA表</span></span><br><span class="line">   <span class="comment">/*p表示LA链表访问到的最后一个位置，q表示LB链表访问到的最后一个位置，r表示LC链表当前的最后一个节点*/</span></span><br><span class="line">   <span class="keyword">while</span>(p  != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p -&gt; data &gt;= q -&gt; data)&#123;</span><br><span class="line">         r -&gt; next = q; </span><br><span class="line">         r = q;</span><br><span class="line">         q = q -&gt; next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">         r -&gt; next = p;</span><br><span class="line">         r = p;</span><br><span class="line">         p = p -&gt; next;</span><br><span class="line">      &#125;</span><br><span class="line">      r -&gt; next  =  p ? p : q; <span class="comment">//p如果非空，则将p赋值给 r -&gt; next,否则将q赋值给r -&gt; next</span></span><br><span class="line">      <span class="comment">/*这一步的目的是将未访问到最后一个结点的表插入到LC表末尾，*/</span></span><br><span class="line">      <span class="built_in">free</span>(LB); <span class="comment">//释放LB头结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="综合应用案例"><a href="#综合应用案例" class="headerlink" title="综合应用案例"></a>综合应用案例</h2><h3 id="稀疏多项式的运算（完整实现）"><a href="#稀疏多项式的运算（完整实现）" class="headerlink" title="稀疏多项式的运算（完整实现）"></a>稀疏多项式的运算<a href="/2025/02/02/%E7%A8%80%E7%96%8F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97%E9%9D%9E%E4%BC%AA%E7%A0%81%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0/">（完整实现）</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PNode</span>&#123;</span><br><span class="line"><span class="type">float</span> coef; <span class="comment">//系数</span></span><br><span class="line"><span class="type">int</span> expn; <span class="comment">//指数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PNode</span>* next; <span class="comment">//指针域</span></span><br><span class="line">&#125;PNode,*Polynomal;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PNode</span>&#123;</span><br><span class="line"><span class="type">float</span> coef; <span class="comment">//系数</span></span><br><span class="line"><span class="type">int</span> expn; <span class="comment">//指数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PNode</span>* next; <span class="comment">//指针域</span></span><br><span class="line">&#125;PNode,*Polynomal;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_L</span><span class="params">(Polynomal LA,Polynomal LB,Polynomal &amp;LC)</span></span>&#123;</span><br><span class="line">   PNode* p = LA -&gt; next;PNode* q = LB -&gt; next; <span class="comment">//p,q指针指向LA,LB两表首元素</span></span><br><span class="line">   PNode* r = LC; <span class="comment">//r指向LC表</span></span><br><span class="line">   <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)&#123;  <span class="comment">//循环条件为LA,LB两表均未到达表尾</span></span><br><span class="line">    <span class="keyword">if</span>(p -&gt; expn == q -&gt; expn)&#123; <span class="comment">//第一层if：p，q指数相等情况</span></span><br><span class="line">      <span class="keyword">if</span>(p -&gt; coef + q -&gt; coef == <span class="number">0</span>)&#123; <span class="comment">//第二层if：判断p，q系数是否相加为零</span></span><br><span class="line">      p = p -&gt; next;</span><br><span class="line">      q = q -&gt; next; <span class="comment">//系数和为零，向后移动p，q指针，两结点均不加入LC表</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123; <span class="comment">//第二层if：p，q系数相加不为零</span></span><br><span class="line">        PNode* s = (PNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(PNode));</span><br><span class="line">        s -&gt; next = <span class="literal">NULL</span>; <span class="comment">//初始化一个s结点以便插入LC表</span></span><br><span class="line">        s -&gt; coef =  p -&gt; coef + q -&gt; coef;</span><br><span class="line">        s -&gt; expn = p -&gt; expn; <span class="comment">//新结点指数为p（或q）指数，系数为p，q系数之和</span></span><br><span class="line">        r -&gt; next = s; <span class="comment">//将s结点插入LC表</span></span><br><span class="line">        r = r -&gt; next;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">      q = q -&gt; next; <span class="comment">//向后移动p，q，r指针</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p -&gt; expn &lt; q -&gt; expn)&#123; <span class="comment">//第一层if：p指数小于q指数</span></span><br><span class="line">        r -&gt; next = p;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        r = r -&gt; next; <span class="comment">//将p所指向结点作为r的下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//第一层if：p指数大于q指数</span></span><br><span class="line">        r -&gt; next = q;</span><br><span class="line">        q = q -&gt; next;</span><br><span class="line">        r = r -&gt; next; <span class="comment">//将q所指向结点作为r的下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">r -&gt; next = p ? p : q; <span class="comment">//p如果非空，则将p赋值给 r -&gt; next,否则将q赋值给r -&gt; next</span></span><br><span class="line">   <span class="comment">/*这一步的目的是将未访问到最后一个结点的表插入到LC表末尾，*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（二）—— 线性表的链式表示及常用操作</title>
      <link href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon simple"><p><strong>数据结构笔记目录：</strong><ol class="series-items"><li><a href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="数据结构与算法（一）—— 线性表的顺序表示及常用操作">数据结构与算法（一）—— 线性表的顺序表示及常用操作</a></li><li><a href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="数据结构与算法（二）—— 线性表的链式表示及常用操作">数据结构与算法（二）—— 线性表的链式表示及常用操作</a></li><li><a href="/2025/01/24/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8/" title="数据结构与算法（三）—— 线性表的应用">数据结构与算法（三）—— 线性表的应用</a></li><li><a href="/2025/02/09/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="数据结构与算法（四）—— 栈和队列">数据结构与算法（四）—— 栈和队列</a></li><li><a href="/2025/02/23/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="数据结构与算法（五）—— 串、数组和广义表">数据结构与算法（五）—— 串、数组和广义表</a></li><li><a href="/2025/03/04/%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构与算法（六）—— 数和二叉树">数据结构与算法（六）—— 数和二叉树</a></li></ol></p></div><h2 id="单链表的表示"><a href="#单链表的表示" class="headerlink" title="单链表的表示"></a>单链表的表示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Lnode</span>&#123;</span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Lnode</span>* next;</span><br><span class="line">&#125;Lnode,*LinkList; <span class="comment">//LinkList为指向结构体Lnode的指针类型</span></span><br><span class="line"><span class="comment">//定义链表</span></span><br><span class="line">LinkList L;</span><br><span class="line"><span class="comment">//定义节点指针p</span></span><br><span class="line">LNode* p;</span><br><span class="line"><span class="comment">//LinkList == LNode*，分开两种定义方式的目的是使定义更加清晰</span></span><br></pre></td></tr></table></figure><h3 id="Ex-1：存储学生信息的单链表"><a href="#Ex-1：存储学生信息的单链表" class="headerlink" title="Ex:1：存储学生信息的单链表"></a>Ex:1：存储学生信息的单链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">  <span class="type">char</span> nom[<span class="number">12</span>]; <span class="comment">//学号数据域</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">8</span>]; <span class="comment">//姓名数据域</span></span><br><span class="line">  <span class="type">int</span> score; <span class="comment">//学生成绩数据域</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">student</span>* next; <span class="comment">//指针域</span></span><br><span class="line">&#125;LNode,* LinkList;</span><br></pre></td></tr></table></figure><h2 id="单链表的初始化、判空、销毁、清空"><a href="#单链表的初始化、判空、销毁、清空" class="headerlink" title="单链表的初始化、判空、销毁、清空"></a>单链表的初始化、判空、销毁、清空</h2><h3 id="单链表的初始化"><a href="#单链表的初始化" class="headerlink" title="单链表的初始化"></a>单链表的初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">initList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  L = (Lnode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Lnode)); <span class="comment">//生成新结点作为头结点，用头指针L指向头结点</span></span><br><span class="line">  L -&gt; next = <span class="literal">NULL</span>; <span class="comment">//将头结点的指针域置空</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表的判空：判断头结点指针域是否为空"><a href="#单链表的判空：判断头结点指针域是否为空" class="headerlink" title="单链表的判空：判断头结点指针域是否为空"></a>单链表的判空：判断头结点指针域是否为空</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListEmpty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表的销毁：从头指针开始，依次释放所有节点"><a href="#单链表的销毁：从头指针开始，依次释放所有节点" class="headerlink" title="单链表的销毁：从头指针开始，依次释放所有节点"></a>单链表的销毁：从头指针开始，依次释放所有节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DestroyList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  Lnode* p;</span><br><span class="line">  <span class="keyword">while</span>(L != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    Lnode* p = L;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表的清空：依次释放所有结点，并将头结点指针域设置为空"><a href="#单链表的清空：依次释放所有结点，并将头结点指针域设置为空" class="headerlink" title="单链表的清空：依次释放所有结点，并将头结点指针域设置为空"></a>单链表的清空：依次释放所有结点，并将头结点指针域设置为空</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ClearList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  Lnode* p = L-&gt;next; <span class="comment">//指向要销毁的结点</span></span><br><span class="line">  Lnode* q; <span class="comment">//指向要销毁的结点的下一个节点</span></span><br><span class="line">  <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    </span><br><span class="line">    Lnode* q = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = q;</span><br><span class="line">  &#125;</span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求单链表的表长"><a href="#求单链表的表长" class="headerlink" title="求单链表的表长"></a>求单链表的表长</h2><h3 id="求单链表的表长-1"><a href="#求单链表的表长-1" class="headerlink" title="求单链表的表长"></a>求单链表的表长</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength_L</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">  Lnode* p = L-&gt;next;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      sum++;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单链表的增删查改"><a href="#单链表的增删查改" class="headerlink" title="单链表的增删查改"></a>单链表的增删查改</h2><h3 id="求单链表的第i个元素"><a href="#求单链表的第i个元素" class="headerlink" title="求单链表的第i个元素"></a>求单链表的第i个元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetElem_L</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">  Lnode* p = L-&gt;next;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>; <span class="comment">//j表示现在p所指向的结点是链表L中的第几个元素</span></span><br><span class="line">  <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125; <span class="comment">//向后扫描，直到p指向第i个元素或p为空（即i超过了链表长度）</span></span><br><span class="line">  <span class="keyword">if</span>( !p || j &gt; i )<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//！p对应i值过大，找不到，j&gt;i对应i太小，不合法</span></span><br><span class="line">  e = p-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表按值查找"><a href="#单链表按值查找" class="headerlink" title="单链表按值查找"></a>单链表按值查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem_L</span><span class="params">(LinkList L,ElemType e)</span></span>&#123;</span><br><span class="line">  Lnode* p = L-&gt;next;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L,ElemType e,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  Lnode* p = L -&gt; next; <span class="comment">//现在指向的结点（头结点非首元结点情况）</span></span><br><span class="line">  Lnode* q = (Lnode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Lnode)); <span class="comment">//创建一个新结点</span></span><br><span class="line">  q -&gt; data = e;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>; <span class="comment">//j表示现在p所指向的结点是链表L中的第几个元素</span></span><br><span class="line">  <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">    p = p -&gt; next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p == <span class="literal">NULL</span> || j &gt; i) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    q -&gt; next = p -&gt; next;</span><br><span class="line">    p -&gt; next = q ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表结点的删除"><a href="#单链表结点的删除" class="headerlink" title="单链表结点的删除"></a>单链表结点的删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">  Lnode* p = L -&gt; next; <span class="comment">//现在指向的结点（头结点非首元结点情况）</span></span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>; <span class="comment">//j表示现在p所指向的结点是链表L中的第几个元素</span></span><br><span class="line">  <span class="keyword">while</span>(j &lt; i - <span class="number">1</span> &amp;&amp; p -&gt; next != <span class="literal">NULL</span>)&#123; <span class="comment">//第二个条件不是p != NULL的原因是遍历的终点是链表最后一个元素的前驱，即倒数第二个元素</span></span><br><span class="line">    p = p -&gt; next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125; <span class="comment">//寻找第i个结点的前驱</span></span><br><span class="line">  <span class="keyword">if</span>(p -&gt; next == <span class="literal">NULL</span> || j &gt; i) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      Lnode* q = p -&gt; next; <span class="comment">//临时保存被删结点的地址以备释放</span></span><br><span class="line">      e = q -&gt; data; <span class="comment">//保存被删除结点数据域</span></span><br><span class="line">      p -&gt; next = q -&gt; next; <span class="comment">//改变被删除节点前驱的指针域（后继）</span></span><br><span class="line">      <span class="built_in">free</span>(q); <span class="comment">//释放被删除结点所占空间</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插法、尾插法建立链表"><a href="#头插法、尾插法建立链表" class="headerlink" title="头插法、尾插法建立链表"></a>头插法、尾插法建立链表</h2><h3 id="头插法建立链表"><a href="#头插法建立链表" class="headerlink" title="头插法建立链表"></a>头插法建立链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList_H</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  L = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeofL</span>(Node));</span><br><span class="line">  L -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = n,i &gt; <span class="number">0</span>,i--)&#123;</span><br><span class="line">    Lnode* p = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    cin &gt;&gt; p -&gt; data;</span><br><span class="line">    p -&gt; next = L -&gt; next;</span><br><span class="line">    L -&gt; next = p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度为O(n)</strong></p><h3 id="尾插法建立链表"><a href="#尾插法建立链表" class="headerlink" title="尾插法建立链表"></a>尾插法建立链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList_E</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  L = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">  L -&gt; next = <span class="literal">NULL</span>; <span class="comment">//建立头结点和指向头节点的指针</span></span><br><span class="line">  Lnode* p = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">  p -&gt; next = L; <span class="comment">//指向当前最后一个结点的结点（尾指针）</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>,i &lt; n,i++)&#123;</span><br><span class="line">    Lnode* q = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); </span><br><span class="line">    q -&gt; next = <span class="literal">NULL</span>; </span><br><span class="line">    cin &gt;&gt; q -&gt; data;<span class="comment">//生成新结点</span></span><br><span class="line">    p -&gt; next = q;</span><br><span class="line">    p = q; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度为O(n)</strong></p><h2 id="链表相关算法的算法分析"><a href="#链表相关算法的算法分析" class="headerlink" title="链表相关算法的算法分析"></a>链表相关算法的算法分析</h2><h3 id="我有看见时间复杂度就犯困的病，所以算法分析明天再看明天再写"><a href="#我有看见时间复杂度就犯困的病，所以算法分析明天再看明天再写" class="headerlink" title="我有看见时间复杂度就犯困的病，所以算法分析明天再看明天再写"></a>我有看见时间复杂度就犯困的病，所以算法分析明天再看明天再写</h3><h3 id="反正链表就差这一部分了，摸了摸了"><a href="#反正链表就差这一部分了，摸了摸了" class="headerlink" title="反正链表就差这一部分了，摸了摸了"></a>反正链表就差这一部分了，摸了摸了</h3><h1 id="To-Be-Continued…"><a href="#To-Be-Continued…" class="headerlink" title="To Be Continued…"></a>To Be Continued…</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（一）—— 线性表的顺序表示及常用操作</title>
      <link href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon simple"><p><strong>数据结构笔记目录：</strong><ol class="series-items"><li><a href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="数据结构与算法（一）—— 线性表的顺序表示及常用操作">数据结构与算法（一）—— 线性表的顺序表示及常用操作</a></li><li><a href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="数据结构与算法（二）—— 线性表的链式表示及常用操作">数据结构与算法（二）—— 线性表的链式表示及常用操作</a></li><li><a href="/2025/01/24/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8/" title="数据结构与算法（三）—— 线性表的应用">数据结构与算法（三）—— 线性表的应用</a></li><li><a href="/2025/02/09/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="数据结构与算法（四）—— 栈和队列">数据结构与算法（四）—— 栈和队列</a></li><li><a href="/2025/02/23/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="数据结构与算法（五）—— 串、数组和广义表">数据结构与算法（五）—— 串、数组和广义表</a></li><li><a href="/2025/03/04/%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构与算法（六）—— 数和二叉树">数据结构与算法（六）—— 数和二叉树</a></li></ol></p></div><h2 id="顺序表的构建"><a href="#顺序表的构建" class="headerlink" title="顺序表的构建"></a>顺序表的构建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_Size 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType elem[max_Size];</span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h3 id="Ex-1"><a href="#Ex-1" class="headerlink" title="Ex:1"></a>Ex:1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_Size 100 <span class="comment">//宏定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> ISBN[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">&#125;Book;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SqList</span>&#123;</span><br><span class="line">    Book* add;<span class="comment">//存储空间基地址</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//当前图书个数</span></span><br><span class="line">&#125;SqList;<span class="comment">//这是一个存放图书信息的顺序表</span></span><br></pre></td></tr></table></figure><h3 id="EX-2：使用动态分配内存方式的顺序表"><a href="#EX-2：使用动态分配内存方式的顺序表" class="headerlink" title="EX:2：使用动态分配内存方式的顺序表"></a>EX:2：使用动态分配内存方式的顺序表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_Size 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SqList</span>&#123;</span><br><span class="line">    ElemType* elem;</span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//主函数中内容</span></span><br><span class="line">SqList L;<span class="comment">//定义顺序表变量L</span></span><br><span class="line">L.elem = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*max_Size);<span class="comment">//动态分配内存</span></span><br></pre></td></tr></table></figure><h2 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList *L,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L-&gt;length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;elem[i] == e)&#123;</span><br><span class="line">    <span class="keyword">return</span> i<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序表的查找算法分析：平均查找长度ASL（Average-Search-Length）"><a href="#顺序表的查找算法分析：平均查找长度ASL（Average-Search-Length）" class="headerlink" title="顺序表的查找算法分析：平均查找长度ASL（Average Search Length）"></a>顺序表的查找算法分析：平均查找长度ASL（Average Search Length）</h3><p><strong>需要与给定值进行比较的关键字的个数的期望值（即查找次数的平均值）叫做查找算法的平均查找长度，用于分析查找算法的时间复杂度</strong></p><p><strong>ASL&#x3D;P1*N1+P2*N2+P3*N3…..</strong>(P为第i个记录被查找的概率，系数N为找到第i个元素须比较的次数)</p><p><strong>关于顺序表的查找算法，有：ASL&#x3D;P*0+P*1+…P*n(P&#x3D;1&#x2F;n)&#x3D;(n+1)&#x2F;2</strong>（查找次数从0到n次）</p><h2 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListInsert_Sq</span><span class="params">(SqList *L,<span class="type">int</span> i，ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;L-&gt;length<span class="number">+1</span>||i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//i值不合法</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length == max_Size) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//顺序表已满</span></span><br><span class="line">    <span class="keyword">for</span>(j=L-&gt;Length<span class="number">-1</span>;j&lt;i;j--)&#123;</span><br><span class="line">        L-&gt;elem[j<span class="number">+1</span>] = L-&gt;elem[j];</span><br><span class="line">        &#125;<span class="comment">//将元素依次向后移空出下标为i-1的位置</span></span><br><span class="line">    L-&gt;elem[i<span class="number">-1</span>] = e;</span><br><span class="line">    l-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序表的插入算法分析"><a href="#顺序表的插入算法分析" class="headerlink" title="顺序表的插入算法分析"></a>顺序表的插入算法分析</h3><p><strong>INS&#x3D;P*1+P*2+…P*n(P&#x3D;1&#x2F;n+1)&#x3D;n&#x2F;2</strong>（移动次数从0次到n次）</p><h2 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListDelete</span><span class="params">(Sqlist *L,<span class="type">int</span> i,ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;L-&gt;length||i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//i值不合法</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//顺序表为空</span></span><br><span class="line">    *e = L-&gt;elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&lt;L.length;j++)&#123;</span><br><span class="line">        L-&gt;elem[j] = L-&gt;elem[j<span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序表的插入算法分析-1"><a href="#顺序表的插入算法分析-1" class="headerlink" title="顺序表的插入算法分析"></a>顺序表的插入算法分析</h3><p><strong>DEL&#x3D;P*1+P*2+…P*(n-1)(P&#x3D;1&#x2F;n)&#x3D;(n-1)&#x2F;2</strong>（移动次数从0到(n-1)）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年度个人拍摄雪景几则</title>
      <link href="/2025/01/11/2024%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%8B%8D%E6%91%84%E9%9B%AA%E6%99%AF%E5%87%A0%E5%88%99/"/>
      <url>/2025/01/11/2024%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%8B%8D%E6%91%84%E9%9B%AA%E6%99%AF%E5%87%A0%E5%88%99/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon simple"><p>最近没在学习什么新技术，但是还是想充实一下这个博客，于是选了几张今年拍摄的一些好看的雪景。这样一来自己在没有雪的想看雪的时候翻一翻博客，还能籍此缓解夏天没有雪看的寂寞心情<br>封面图是中秋节在学校附近的公园放烟花时候拍的，感觉闪闪的很漂亮，就拿来做封面了。</p></div><h2 id="这两张是年初时在老家拍摄的"><a href="#这两张是年初时在老家拍摄的" class="headerlink" title="这两张是年初时在老家拍摄的"></a>这两张是年初时在老家拍摄的</h2><h3 id="我特别喜欢待在这条小山路上看雪！耳机里放着春卷饭冬日的歌，待在没什么人的小角落，望着眼前一片白茫茫，感觉格外的宁静。"><a href="#我特别喜欢待在这条小山路上看雪！耳机里放着春卷饭冬日的歌，待在没什么人的小角落，望着眼前一片白茫茫，感觉格外的宁静。" class="headerlink" title="我特别喜欢待在这条小山路上看雪！耳机里放着春卷饭冬日的歌，待在没什么人的小角落，望着眼前一片白茫茫，感觉格外的宁静。"></a>我特别喜欢待在这条小山路上看雪！耳机里放着春卷饭冬日的歌，待在没什么人的小角落，望着眼前一片白茫茫，感觉格外的宁静。</h3><img class="inline-img" src="/images/yuki_Img_1.jpg" style="height:250px" /><img class="inline-img" src="/images/yuki_Img_2.jpg" style="height:250px" /><h2 id="这几张是今年年末在学校拍的"><a href="#这几张是今年年末在学校拍的" class="headerlink" title="这几张是今年年末在学校拍的"></a>这几张是今年年末在学校拍的</h2><h3 id="呼和浩特的冬天真是暖的出奇，今年冬天一共就下了三场雪，所以在同样的机位拍了三张"><a href="#呼和浩特的冬天真是暖的出奇，今年冬天一共就下了三场雪，所以在同样的机位拍了三张" class="headerlink" title="呼和浩特的冬天真是暖的出奇，今年冬天一共就下了三场雪，所以在同样的机位拍了三张"></a>呼和浩特的冬天真是暖的出奇，今年冬天一共就下了三场雪，所以在同样的机位拍了三张</h3><img class="inline-img" src="/images/yuki_Img_3.jpg" style="height:180px" /><img class="inline-img" src="/images/yuki_Img_4.jpg" style="height:180px" /><img class="inline-img" src="/images/yuki_Img_5.jpg" style="height:180px" /><h3 id="雪一次比一次大了！（话说不这样才奇怪吧）"><a href="#雪一次比一次大了！（话说不这样才奇怪吧）" class="headerlink" title="雪一次比一次大了！（话说不这样才奇怪吧）"></a>雪一次比一次大了！（话说不这样才奇怪吧）</h3><h2 id="这张是我最喜欢的一张！"><a href="#这张是我最喜欢的一张！" class="headerlink" title="这张是我最喜欢的一张！"></a>这张是我最喜欢的一张！</h2><h3 id="无人的角落，飘落的黄叶，以雪为衣的大树，感觉心里暖暖的。冬天最吸引人的正是在于刺骨的寒风衬托出的暖洋洋的感觉啊！脖子上的围巾，室内的暖气，寒风浸透的全身被各种各样暖洋洋的东西一点点的焐热的感觉真是太棒了！"><a href="#无人的角落，飘落的黄叶，以雪为衣的大树，感觉心里暖暖的。冬天最吸引人的正是在于刺骨的寒风衬托出的暖洋洋的感觉啊！脖子上的围巾，室内的暖气，寒风浸透的全身被各种各样暖洋洋的东西一点点的焐热的感觉真是太棒了！" class="headerlink" title="无人的角落，飘落的黄叶，以雪为衣的大树，感觉心里暖暖的。冬天最吸引人的正是在于刺骨的寒风衬托出的暖洋洋的感觉啊！脖子上的围巾，室内的暖气，寒风浸透的全身被各种各样暖洋洋的东西一点点的焐热的感觉真是太棒了！"></a>无人的角落，飘落的黄叶，以雪为衣的大树，感觉心里暖暖的。冬天最吸引人的正是在于刺骨的寒风衬托出的暖洋洋的感觉啊！脖子上的围巾，室内的暖气，寒风浸透的全身被各种各样暖洋洋的东西一点点的焐热的感觉真是太棒了！</h3><p><img src="/images/yuki_Img_6.jpg"></p><h2 id="并不是雪景的论外一则"><a href="#并不是雪景的论外一则" class="headerlink" title="并不是雪景的论外一则"></a>并不是雪景的论外一则</h2><h3 id="是工程实训课上用数控铣打出来的亚克力片片，感觉像是琥珀把雪花包在里面了一样，很喜欢"><a href="#是工程实训课上用数控铣打出来的亚克力片片，感觉像是琥珀把雪花包在里面了一样，很喜欢" class="headerlink" title="是工程实训课上用数控铣打出来的亚克力片片，感觉像是琥珀把雪花包在里面了一样，很喜欢"></a>是工程实训课上用数控铣打出来的亚克力片片，感觉像是琥珀把雪花包在里面了一样，很喜欢</h3><p><img src="/images/yuki_Img_7.jpg"></p><h3 id="突然发现这篇博客插了好多图片，图都是存在项目里的，本来想到博客应该用不到很多图所以就全存本地了，这下看来不得不搞个图床来存了"><a href="#突然发现这篇博客插了好多图片，图都是存在项目里的，本来想到博客应该用不到很多图所以就全存本地了，这下看来不得不搞个图床来存了" class="headerlink" title="突然发现这篇博客插了好多图片，图都是存在项目里的，本来想到博客应该用不到很多图所以就全存本地了，这下看来不得不搞个图床来存了"></a>突然发现这篇博客插了好多图片，图都是存在项目里的，本来想到博客应该用不到很多图所以就全存本地了，这下看来不得不搞个图床来存了</h3><h3 id="以上！希望2025能拍到更多好看的雪景！！"><a href="#以上！希望2025能拍到更多好看的雪景！！" class="headerlink" title="以上！希望2025能拍到更多好看的雪景！！"></a>以上！希望2025能拍到更多好看的雪景！！</h3>]]></content>
      
      
      <categories>
          
          <category> 雪景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雪景 </tag>
            
            <tag> 照片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于在Hexo的butterfly插件中添加本地搜索功能的方法及细节补充</title>
      <link href="/2025/01/09/1st/"/>
      <url>/2025/01/09/1st/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为看到的所有教程都漏掉了一小步，可能会有人对此纠结很久，遂决定新写一篇文章，同时作为本站的第一篇文章，希望能帮到其他被此问题困扰的朋友</p></blockquote><h2 id="博客根目录安装插件"><a href="#博客根目录安装插件" class="headerlink" title="博客根目录安装插件"></a>博客根目录安装插件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><h3 id="在根目录-config-yml文件添加如下文本"><a href="#在根目录-config-yml文件添加如下文本" class="headerlink" title="在根目录_config.yml文件添加如下文本"></a>在根目录_config.yml文件添加如下文本</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><h3 id="将-config-butterfly-yml文件中的search段中的use键的值改为local-search"><a href="#将-config-butterfly-yml文件中的search段中的use键的值改为local-search" class="headerlink" title="将_config.butterfly.yml文件中的search段中的use键的值改为local_search"></a>将_config.butterfly.yml文件中的search段中的use键的值改为local_search</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="string">use：local_search</span></span><br><span class="line">    <span class="comment"># 注意！！一定要在“：”和“Local_search”中间添加空格</span></span><br><span class="line">    <span class="comment"># 所有的教程都少了这一步</span></span><br></pre></td></tr></table></figure><h3 id="将-config-butterfly-yml文件中的local-search段中的enable键的值改为true，如没有此键则添加"><a href="#将-config-butterfly-yml文件中的local-search段中的enable键的值改为true，如没有此键则添加" class="headerlink" title="将_config.butterfly.yml文件中的local_search段中的enable键的值改为true，如没有此键则添加"></a>将_config.butterfly.yml文件中的local_search段中的enable键的值改为true，如没有此键则添加</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="string">enable：true</span></span><br></pre></td></tr></table></figure><h2 id="检查是否设置成功"><a href="#检查是否设置成功" class="headerlink" title="检查是否设置成功"></a>检查是否设置成功</h2><h3 id="本地检查"><a href="#本地检查" class="headerlink" title="本地检查"></a>本地检查</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl;hexo s</span><br></pre></td></tr></table></figure><h3 id="检查无误后推送至仓库"><a href="#检查无误后推送至仓库" class="headerlink" title="检查无误后推送至仓库"></a>检查无误后推送至仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl ; hexo generate ; hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 技术 </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
